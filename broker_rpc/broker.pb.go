// Code generated by protoc-gen-go. DO NOT EDIT.
// source: broker.proto

/*
Package broker_rpc is a generated protocol buffer package.

It is generated from these files:
	broker.proto

It has these top-level messages:
	Google
	HealthCheckResponse
	GetIdentityResponse
	CreateBlockOrderRequest
	CreateBlockOrderResponse
	Order
	Fill
	BlockOrder
	GetBlockOrderRequest
	GetBlockOrderResponse
	CancelBlockOrderRequest
	GetBlockOrdersResponse
	GetBlockOrdersRequest
	WatchMarketRequest
	WatchMarketResponse
	MarketEvent
	GetOrderbookRequest
	Bid
	Ask
	GetOrderbookResponse
	NewDepositAddressRequest
	NewDepositAddressResponse
	Balance
	GetBalancesResponse
	Capacity
	GetTradingCapacitiesResponse
	GetTradingCapacitiesRequest
	CommitRequest
	ReleaseChannelsRequest
	ReleasedCurrency
	ReleaseChannelsResponse
	GetPaymentChannelNetworkAddressRequest
	GetPaymentChannelNetworkAddressResponse
	WithdrawFundsRequest
	WithdrawFundsResponse
	CreateWalletRequest
	CreateWalletResponse
	UnlockWalletRequest
	SupportedMarket
	GetSupportedMarketsResponse
	GetMarketStatsRequest
	GetMarketStatsResponse
	GetTradesRequest
	Trade
	GetTradesResponse
*/
package broker_rpc

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "google.golang.org/genproto/googleapis/api/annotations"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// *
// Side is one of the two sides of any market.
type Side int32

const (
	// A BID is the buy side of a market.
	Side_BID Side = 0
	// An ASK is the sell side of a market.
	Side_ASK Side = 1
)

var Side_name = map[int32]string{
	0: "BID",
	1: "ASK",
}
var Side_value = map[string]int32{
	"BID": 0,
	"ASK": 1,
}

func (x Side) String() string {
	return proto.EnumName(Side_name, int32(x))
}
func (Side) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

// *
// The time restriction for an order given by the user to the Broker.
// It is important to note that this time in force only controls the Broker's actions and does not correspond to a time-in-force on the underlying network.
type TimeInForce int32

const (
	TimeInForce_GTC TimeInForce = 0
	TimeInForce_FOK TimeInForce = 1
	TimeInForce_IOC TimeInForce = 2
)

var TimeInForce_name = map[int32]string{
	0: "GTC",
	1: "FOK",
	2: "IOC",
}
var TimeInForce_value = map[string]int32{
	"GTC": 0,
	"FOK": 1,
	"IOC": 2,
}

func (x TimeInForce) String() string {
	return proto.EnumName(TimeInForce_name, int32(x))
}
func (TimeInForce) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

// *
// Symbol is the common representation of a given currency.
type Symbol int32

const (
	// Bitcoin
	Symbol_BTC Symbol = 0
	// Litecoin
	Symbol_LTC Symbol = 1
)

var Symbol_name = map[int32]string{
	0: "BTC",
	1: "LTC",
}
var Symbol_value = map[string]int32{
	"BTC": 0,
	"LTC": 1,
}

func (x Symbol) String() string {
	return proto.EnumName(Symbol_name, int32(x))
}
func (Symbol) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

// *
// Status of an order on the SparkSwap Relayer.
type Order_OrderStatus int32

const (
	// The order has been created on the Relayer.
	Order_CREATED Order_OrderStatus = 0
	// The order has been placed and communicated to other marker participants.
	Order_PLACED Order_OrderStatus = 1
	// The order has been filled by another market participant.
	Order_FILLED Order_OrderStatus = 2
	// The swap has been executed on the Payment Channel Networks
	Order_EXECUTED Order_OrderStatus = 3
	// The swap preimage has been returned to the Relayer.
	Order_COMPLETED Order_OrderStatus = 4
	// The order has encountered a failure.
	Order_REJECTED Order_OrderStatus = 5
)

var Order_OrderStatus_name = map[int32]string{
	0: "CREATED",
	1: "PLACED",
	2: "FILLED",
	3: "EXECUTED",
	4: "COMPLETED",
	5: "REJECTED",
}
var Order_OrderStatus_value = map[string]int32{
	"CREATED":   0,
	"PLACED":    1,
	"FILLED":    2,
	"EXECUTED":  3,
	"COMPLETED": 4,
	"REJECTED":  5,
}

func (x Order_OrderStatus) String() string {
	return proto.EnumName(Order_OrderStatus_name, int32(x))
}
func (Order_OrderStatus) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{5, 0} }

// *
// Status of the fill on the SparkSwap Relayer.
type Fill_FillStatus int32

const (
	// The fill has been created on the Relayer.
	Fill_CREATED Fill_FillStatus = 0
	// The fill has been accepted as the fill for the given order.
	Fill_FILLED Fill_FillStatus = 1
	// The swap has been executed on the Payment Channel Networks.
	Fill_EXECUTED Fill_FillStatus = 2
	// The preimage has been returned to the Relayer by the Maker.
	Fill_COMPLETED Fill_FillStatus = 3
	// The fill has encountered a failure.
	Fill_REJECTED Fill_FillStatus = 4
)

var Fill_FillStatus_name = map[int32]string{
	0: "CREATED",
	1: "FILLED",
	2: "EXECUTED",
	3: "COMPLETED",
	4: "REJECTED",
}
var Fill_FillStatus_value = map[string]int32{
	"CREATED":   0,
	"FILLED":    1,
	"EXECUTED":  2,
	"COMPLETED": 3,
	"REJECTED":  4,
}

func (x Fill_FillStatus) String() string {
	return proto.EnumName(Fill_FillStatus_name, int32(x))
}
func (Fill_FillStatus) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{6, 0} }

// *
// Status of the block order on the Broker.
type BlockOrder_BlockOrderStatus int32

const (
	// The block order is still being worked by the Broker.
	BlockOrder_ACTIVE BlockOrder_BlockOrderStatus = 0
	// The block order was cancelled by the user.
	BlockOrder_CANCELLED BlockOrder_BlockOrderStatus = 1
	// The block order has successfully completed execution.
	BlockOrder_COMPLETED BlockOrder_BlockOrderStatus = 2
	// The block order has failed at some point and is no longer attempting execution.
	BlockOrder_FAILED BlockOrder_BlockOrderStatus = 3
)

var BlockOrder_BlockOrderStatus_name = map[int32]string{
	0: "ACTIVE",
	1: "CANCELLED",
	2: "COMPLETED",
	3: "FAILED",
}
var BlockOrder_BlockOrderStatus_value = map[string]int32{
	"ACTIVE":    0,
	"CANCELLED": 1,
	"COMPLETED": 2,
	"FAILED":    3,
}

func (x BlockOrder_BlockOrderStatus) String() string {
	return proto.EnumName(BlockOrder_BlockOrderStatus_name, int32(x))
}
func (BlockOrder_BlockOrderStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{7, 0}
}

// *
// Types of events, used to distinguish between adding orders to a market and removing them.
type WatchMarketResponse_EventType int32

const (
	// Add an event to a market, typically due to an order being placed.
	WatchMarketResponse_ADD WatchMarketResponse_EventType = 0
	// Remove an event from the market, typically due to an order being cancelled or filled.
	WatchMarketResponse_DELETE WatchMarketResponse_EventType = 1
)

var WatchMarketResponse_EventType_name = map[int32]string{
	0: "ADD",
	1: "DELETE",
}
var WatchMarketResponse_EventType_value = map[string]int32{
	"ADD":    0,
	"DELETE": 1,
}

func (x WatchMarketResponse_EventType) String() string {
	return proto.EnumName(WatchMarketResponse_EventType_name, int32(x))
}
func (WatchMarketResponse_EventType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{14, 0}
}

// import "google/protobuf/empty.proto";
// normally we would us the above import statement, but the node.js grpc doesn't import
// the standard types and so it throws an error message saying that it can't find google/protobuf.empty.proto
// Instead, we define our own Empty message that is equivalent.
type Google struct {
}

func (m *Google) Reset()                    { *m = Google{} }
func (m *Google) String() string            { return proto.CompactTextString(m) }
func (*Google) ProtoMessage()               {}
func (*Google) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type GoogleProtobuf struct {
}

func (m *GoogleProtobuf) Reset()                    { *m = GoogleProtobuf{} }
func (m *GoogleProtobuf) String() string            { return proto.CompactTextString(m) }
func (*GoogleProtobuf) ProtoMessage()               {}
func (*GoogleProtobuf) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0, 0} }

type GoogleProtobuf_Empty struct {
}

func (m *GoogleProtobuf_Empty) Reset()                    { *m = GoogleProtobuf_Empty{} }
func (m *GoogleProtobuf_Empty) String() string            { return proto.CompactTextString(m) }
func (*GoogleProtobuf_Empty) ProtoMessage()               {}
func (*GoogleProtobuf_Empty) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0, 0, 0} }

// *
// HealthCheckResponse provides information on the health of a BrokerDaemon.
type HealthCheckResponse struct {
	// The status of every engine available on the BrokerDaemon.
	EngineStatus []*HealthCheckResponse_EngineStatus `protobuf:"bytes,1,rep,name=engine_status,json=engineStatus" json:"engine_status,omitempty"`
	// The status of the relayer this BrokerDaemon is connected to, either `'OK'` or the error message returned when connecting to it.
	RelayerStatus string `protobuf:"bytes,2,opt,name=relayer_status,json=relayerStatus" json:"relayer_status,omitempty"`
}

func (m *HealthCheckResponse) Reset()                    { *m = HealthCheckResponse{} }
func (m *HealthCheckResponse) String() string            { return proto.CompactTextString(m) }
func (*HealthCheckResponse) ProtoMessage()               {}
func (*HealthCheckResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *HealthCheckResponse) GetEngineStatus() []*HealthCheckResponse_EngineStatus {
	if m != nil {
		return m.EngineStatus
	}
	return nil
}

func (m *HealthCheckResponse) GetRelayerStatus() string {
	if m != nil {
		return m.RelayerStatus
	}
	return ""
}

// *
// EngineStatus provides the status of an engine for a currency.
type HealthCheckResponse_EngineStatus struct {
	// The common symbol that the engine is responsible for, e.g. `BTC` or `LTC`
	Symbol string `protobuf:"bytes,1,opt,name=symbol" json:"symbol,omitempty"`
	// The status of the engine, either `'OK'` or the error message returned when accessing it.
	Status string `protobuf:"bytes,2,opt,name=status" json:"status,omitempty"`
}

func (m *HealthCheckResponse_EngineStatus) Reset()         { *m = HealthCheckResponse_EngineStatus{} }
func (m *HealthCheckResponse_EngineStatus) String() string { return proto.CompactTextString(m) }
func (*HealthCheckResponse_EngineStatus) ProtoMessage()    {}
func (*HealthCheckResponse_EngineStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{1, 0}
}

func (m *HealthCheckResponse_EngineStatus) GetSymbol() string {
	if m != nil {
		return m.Symbol
	}
	return ""
}

func (m *HealthCheckResponse_EngineStatus) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

// *
// GetIdentityResponse provides the Public Key of the BrokerDaemon
type GetIdentityResponse struct {
	// The public key of the BrokerDaemon used to authenticate interactions with the Relayer
	PublicKey string `protobuf:"bytes,1,opt,name=public_key,json=publicKey" json:"public_key,omitempty"`
}

func (m *GetIdentityResponse) Reset()                    { *m = GetIdentityResponse{} }
func (m *GetIdentityResponse) String() string            { return proto.CompactTextString(m) }
func (*GetIdentityResponse) ProtoMessage()               {}
func (*GetIdentityResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *GetIdentityResponse) GetPublicKey() string {
	if m != nil {
		return m.PublicKey
	}
	return ""
}

// *
// Parameters to create a block order on the Broker.
type CreateBlockOrderRequest struct {
	// The market to place the block order in, e.g. `'BTC/LTC'`. Markets are always expressed as the combination of two common symbols, separated by a `/`.
	Market string `protobuf:"bytes,1,opt,name=market" json:"market,omitempty"`
	// Side of the market that the user wishes to take.
	Side Side `protobuf:"varint,2,opt,name=side,enum=broker.rpc.Side" json:"side,omitempty"`
	// Amount, in common units for a currency (e.g. bitcoins for BTC) that is the size of the order. This field supports decimal representation of units but uses a string since protobuf lacks a decimal type (e.g. `'0.16'`)
	Amount string `protobuf:"bytes,3,opt,name=amount" json:"amount,omitempty"`
	// Types that are valid to be assigned to PriceRestriction:
	//	*CreateBlockOrderRequest_IsMarketOrder
	//	*CreateBlockOrderRequest_LimitPrice
	PriceRestriction isCreateBlockOrderRequest_PriceRestriction `protobuf_oneof:"price_restriction"`
	// Time restriction for this block order.
	TimeInForce TimeInForce `protobuf:"varint,6,opt,name=time_in_force,json=timeInForce,enum=broker.rpc.TimeInForce" json:"time_in_force,omitempty"`
}

func (m *CreateBlockOrderRequest) Reset()                    { *m = CreateBlockOrderRequest{} }
func (m *CreateBlockOrderRequest) String() string            { return proto.CompactTextString(m) }
func (*CreateBlockOrderRequest) ProtoMessage()               {}
func (*CreateBlockOrderRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

type isCreateBlockOrderRequest_PriceRestriction interface{ isCreateBlockOrderRequest_PriceRestriction() }

type CreateBlockOrderRequest_IsMarketOrder struct {
	IsMarketOrder bool `protobuf:"varint,4,opt,name=is_market_order,json=isMarketOrder,oneof"`
}
type CreateBlockOrderRequest_LimitPrice struct {
	LimitPrice string `protobuf:"bytes,5,opt,name=limit_price,json=limitPrice,oneof"`
}

func (*CreateBlockOrderRequest_IsMarketOrder) isCreateBlockOrderRequest_PriceRestriction() {}
func (*CreateBlockOrderRequest_LimitPrice) isCreateBlockOrderRequest_PriceRestriction()    {}

func (m *CreateBlockOrderRequest) GetPriceRestriction() isCreateBlockOrderRequest_PriceRestriction {
	if m != nil {
		return m.PriceRestriction
	}
	return nil
}

func (m *CreateBlockOrderRequest) GetMarket() string {
	if m != nil {
		return m.Market
	}
	return ""
}

func (m *CreateBlockOrderRequest) GetSide() Side {
	if m != nil {
		return m.Side
	}
	return Side_BID
}

func (m *CreateBlockOrderRequest) GetAmount() string {
	if m != nil {
		return m.Amount
	}
	return ""
}

func (m *CreateBlockOrderRequest) GetIsMarketOrder() bool {
	if x, ok := m.GetPriceRestriction().(*CreateBlockOrderRequest_IsMarketOrder); ok {
		return x.IsMarketOrder
	}
	return false
}

func (m *CreateBlockOrderRequest) GetLimitPrice() string {
	if x, ok := m.GetPriceRestriction().(*CreateBlockOrderRequest_LimitPrice); ok {
		return x.LimitPrice
	}
	return ""
}

func (m *CreateBlockOrderRequest) GetTimeInForce() TimeInForce {
	if m != nil {
		return m.TimeInForce
	}
	return TimeInForce_GTC
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*CreateBlockOrderRequest) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _CreateBlockOrderRequest_OneofMarshaler, _CreateBlockOrderRequest_OneofUnmarshaler, _CreateBlockOrderRequest_OneofSizer, []interface{}{
		(*CreateBlockOrderRequest_IsMarketOrder)(nil),
		(*CreateBlockOrderRequest_LimitPrice)(nil),
	}
}

func _CreateBlockOrderRequest_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*CreateBlockOrderRequest)
	// price_restriction
	switch x := m.PriceRestriction.(type) {
	case *CreateBlockOrderRequest_IsMarketOrder:
		t := uint64(0)
		if x.IsMarketOrder {
			t = 1
		}
		b.EncodeVarint(4<<3 | proto.WireVarint)
		b.EncodeVarint(t)
	case *CreateBlockOrderRequest_LimitPrice:
		b.EncodeVarint(5<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.LimitPrice)
	case nil:
	default:
		return fmt.Errorf("CreateBlockOrderRequest.PriceRestriction has unexpected type %T", x)
	}
	return nil
}

func _CreateBlockOrderRequest_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*CreateBlockOrderRequest)
	switch tag {
	case 4: // price_restriction.is_market_order
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.PriceRestriction = &CreateBlockOrderRequest_IsMarketOrder{x != 0}
		return true, err
	case 5: // price_restriction.limit_price
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.PriceRestriction = &CreateBlockOrderRequest_LimitPrice{x}
		return true, err
	default:
		return false, nil
	}
}

func _CreateBlockOrderRequest_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*CreateBlockOrderRequest)
	// price_restriction
	switch x := m.PriceRestriction.(type) {
	case *CreateBlockOrderRequest_IsMarketOrder:
		n += proto.SizeVarint(4<<3 | proto.WireVarint)
		n += 1
	case *CreateBlockOrderRequest_LimitPrice:
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.LimitPrice)))
		n += len(x.LimitPrice)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// *
// Response from the broker after creating a block order.
type CreateBlockOrderResponse struct {
	// The unique ID of the block order assigned by the broker. This is used to retrieve information about the order and to cancel it.
	BlockOrderId string `protobuf:"bytes,1,opt,name=block_order_id,json=blockOrderId" json:"block_order_id,omitempty"`
}

func (m *CreateBlockOrderResponse) Reset()                    { *m = CreateBlockOrderResponse{} }
func (m *CreateBlockOrderResponse) String() string            { return proto.CompactTextString(m) }
func (*CreateBlockOrderResponse) ProtoMessage()               {}
func (*CreateBlockOrderResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *CreateBlockOrderResponse) GetBlockOrderId() string {
	if m != nil {
		return m.BlockOrderId
	}
	return ""
}

// *
// An order on the SparkSwap Relayer.
type Order struct {
	// Unique ID assigned by the Relayer for this order.
	OrderId string `protobuf:"bytes,1,opt,name=order_id,json=orderId" json:"order_id,omitempty"`
	// Status of the order on the Relayer.
	OrderStatus Order_OrderStatus `protobuf:"varint,2,opt,name=order_status,json=orderStatus,enum=broker.rpc.Order_OrderStatus" json:"order_status,omitempty"`
	// Amount of the order expressed in a decimal string of common units for a currency (e.g. bitcoins for BTC).
	Amount string `protobuf:"bytes,3,opt,name=amount" json:"amount,omitempty"`
	// Price at which the order was placed, expressed as a decimal string ratio between the common units of the currencies (e.g. litecoins to bitcoins, not litoshis to satoshis). All orders on the SparkSwap Relayer have prices.
	Price string `protobuf:"bytes,4,opt,name=price" json:"price,omitempty"`
	// Any error messages related to the status of a REJECTED or FAILED order
	OrderError string `protobuf:"bytes,6,opt,name=order_error,json=orderError" json:"order_error,omitempty"`
}

func (m *Order) Reset()                    { *m = Order{} }
func (m *Order) String() string            { return proto.CompactTextString(m) }
func (*Order) ProtoMessage()               {}
func (*Order) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *Order) GetOrderId() string {
	if m != nil {
		return m.OrderId
	}
	return ""
}

func (m *Order) GetOrderStatus() Order_OrderStatus {
	if m != nil {
		return m.OrderStatus
	}
	return Order_CREATED
}

func (m *Order) GetAmount() string {
	if m != nil {
		return m.Amount
	}
	return ""
}

func (m *Order) GetPrice() string {
	if m != nil {
		return m.Price
	}
	return ""
}

func (m *Order) GetOrderError() string {
	if m != nil {
		return m.OrderError
	}
	return ""
}

// *
// A fill of an order on the SparkSwap Relayer.
type Fill struct {
	// The Relayer-assigned unique ID of the order that this fill is for.
	OrderId string `protobuf:"bytes,1,opt,name=order_id,json=orderId" json:"order_id,omitempty"`
	// The Relayer-assignded unique ID for this fill.
	FillId string `protobuf:"bytes,2,opt,name=fill_id,json=fillId" json:"fill_id,omitempty"`
	// Status of the fill on the Relayer.
	FillStatus Fill_FillStatus `protobuf:"varint,3,opt,name=fill_status,json=fillStatus,enum=broker.rpc.Fill_FillStatus" json:"fill_status,omitempty"`
	// Amount of the order to fill, expressed in a decimal string of common units for a currency (e.g. bitcoins for BTC). This can be any amount greater than zero and less than or equal to the amount in the order.
	Amount string `protobuf:"bytes,4,opt,name=amount" json:"amount,omitempty"`
	// Price at which the order was placed, expressed as a decimal string ratio between the common units of the currencies (e.g. litecoins to bitcoins, not litoshis to satoshis). All orders on the SparkSwap Relayer have prices.
	Price string `protobuf:"bytes,5,opt,name=price" json:"price,omitempty"`
	// Any error messages related to the status of a REJECTED or FAILED fill
	FillError string `protobuf:"bytes,6,opt,name=fill_error,json=fillError" json:"fill_error,omitempty"`
}

func (m *Fill) Reset()                    { *m = Fill{} }
func (m *Fill) String() string            { return proto.CompactTextString(m) }
func (*Fill) ProtoMessage()               {}
func (*Fill) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *Fill) GetOrderId() string {
	if m != nil {
		return m.OrderId
	}
	return ""
}

func (m *Fill) GetFillId() string {
	if m != nil {
		return m.FillId
	}
	return ""
}

func (m *Fill) GetFillStatus() Fill_FillStatus {
	if m != nil {
		return m.FillStatus
	}
	return Fill_CREATED
}

func (m *Fill) GetAmount() string {
	if m != nil {
		return m.Amount
	}
	return ""
}

func (m *Fill) GetPrice() string {
	if m != nil {
		return m.Price
	}
	return ""
}

func (m *Fill) GetFillError() string {
	if m != nil {
		return m.FillError
	}
	return ""
}

// *
// An order placed by a user on a Broker.
// These are called Block Orders because they are for (relatively) large blocks that get broken up into individual Orders and Fills on the Relayer.
type BlockOrder struct {
	// The unique ID for the block order assigned by the Broker.
	BlockOrderId string `protobuf:"bytes,1,opt,name=block_order_id,json=blockOrderId" json:"block_order_id,omitempty"`
	// The market that the block order is for, e.g. `'BTC/LTC'`. Markets are always expressed as the combination of two common symbols, separated by a `/`.
	Market string `protobuf:"bytes,2,opt,name=market" json:"market,omitempty"`
	// The side of the market that the block order is taking.
	Side Side `protobuf:"varint,3,opt,name=side,enum=broker.rpc.Side" json:"side,omitempty"`
	// Amount, in common units for a currency (e.g. bitcoins for BTC) that is the size of the order. This field supports decimal representation of units but uses a string since protobuf lacks a decimal type (e.g. `'0.16'`)
	Amount string `protobuf:"bytes,4,opt,name=amount" json:"amount,omitempty"`
	// Types that are valid to be assigned to PriceRestriction:
	//	*BlockOrder_IsMarketOrder
	//	*BlockOrder_LimitPrice
	PriceRestriction isBlockOrder_PriceRestriction `protobuf_oneof:"price_restriction"`
	// Time restriction for this block order.
	TimeInForce TimeInForce `protobuf:"varint,5,opt,name=time_in_force,json=timeInForce,enum=broker.rpc.TimeInForce" json:"time_in_force,omitempty"`
	// Current status of the block order.
	Status BlockOrder_BlockOrderStatus `protobuf:"varint,6,opt,name=status,enum=broker.rpc.BlockOrder_BlockOrderStatus" json:"status,omitempty"`
	// BlockOrder creation unix timestamp in nanoseconds
	Timestamp string `protobuf:"bytes,7,opt,name=timestamp" json:"timestamp,omitempty"`
	// BlockOrder creation ISO8601 datetime in nanoseconds
	Datetime string `protobuf:"bytes,8,opt,name=datetime" json:"datetime,omitempty"`
}

func (m *BlockOrder) Reset()                    { *m = BlockOrder{} }
func (m *BlockOrder) String() string            { return proto.CompactTextString(m) }
func (*BlockOrder) ProtoMessage()               {}
func (*BlockOrder) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

type isBlockOrder_PriceRestriction interface{ isBlockOrder_PriceRestriction() }

type BlockOrder_IsMarketOrder struct {
	IsMarketOrder bool `protobuf:"varint,13,opt,name=is_market_order,json=isMarketOrder,oneof"`
}
type BlockOrder_LimitPrice struct {
	LimitPrice string `protobuf:"bytes,14,opt,name=limit_price,json=limitPrice,oneof"`
}

func (*BlockOrder_IsMarketOrder) isBlockOrder_PriceRestriction() {}
func (*BlockOrder_LimitPrice) isBlockOrder_PriceRestriction()    {}

func (m *BlockOrder) GetPriceRestriction() isBlockOrder_PriceRestriction {
	if m != nil {
		return m.PriceRestriction
	}
	return nil
}

func (m *BlockOrder) GetBlockOrderId() string {
	if m != nil {
		return m.BlockOrderId
	}
	return ""
}

func (m *BlockOrder) GetMarket() string {
	if m != nil {
		return m.Market
	}
	return ""
}

func (m *BlockOrder) GetSide() Side {
	if m != nil {
		return m.Side
	}
	return Side_BID
}

func (m *BlockOrder) GetAmount() string {
	if m != nil {
		return m.Amount
	}
	return ""
}

func (m *BlockOrder) GetIsMarketOrder() bool {
	if x, ok := m.GetPriceRestriction().(*BlockOrder_IsMarketOrder); ok {
		return x.IsMarketOrder
	}
	return false
}

func (m *BlockOrder) GetLimitPrice() string {
	if x, ok := m.GetPriceRestriction().(*BlockOrder_LimitPrice); ok {
		return x.LimitPrice
	}
	return ""
}

func (m *BlockOrder) GetTimeInForce() TimeInForce {
	if m != nil {
		return m.TimeInForce
	}
	return TimeInForce_GTC
}

func (m *BlockOrder) GetStatus() BlockOrder_BlockOrderStatus {
	if m != nil {
		return m.Status
	}
	return BlockOrder_ACTIVE
}

func (m *BlockOrder) GetTimestamp() string {
	if m != nil {
		return m.Timestamp
	}
	return ""
}

func (m *BlockOrder) GetDatetime() string {
	if m != nil {
		return m.Datetime
	}
	return ""
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*BlockOrder) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _BlockOrder_OneofMarshaler, _BlockOrder_OneofUnmarshaler, _BlockOrder_OneofSizer, []interface{}{
		(*BlockOrder_IsMarketOrder)(nil),
		(*BlockOrder_LimitPrice)(nil),
	}
}

func _BlockOrder_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*BlockOrder)
	// price_restriction
	switch x := m.PriceRestriction.(type) {
	case *BlockOrder_IsMarketOrder:
		t := uint64(0)
		if x.IsMarketOrder {
			t = 1
		}
		b.EncodeVarint(13<<3 | proto.WireVarint)
		b.EncodeVarint(t)
	case *BlockOrder_LimitPrice:
		b.EncodeVarint(14<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.LimitPrice)
	case nil:
	default:
		return fmt.Errorf("BlockOrder.PriceRestriction has unexpected type %T", x)
	}
	return nil
}

func _BlockOrder_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*BlockOrder)
	switch tag {
	case 13: // price_restriction.is_market_order
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.PriceRestriction = &BlockOrder_IsMarketOrder{x != 0}
		return true, err
	case 14: // price_restriction.limit_price
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.PriceRestriction = &BlockOrder_LimitPrice{x}
		return true, err
	default:
		return false, nil
	}
}

func _BlockOrder_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*BlockOrder)
	// price_restriction
	switch x := m.PriceRestriction.(type) {
	case *BlockOrder_IsMarketOrder:
		n += proto.SizeVarint(13<<3 | proto.WireVarint)
		n += 1
	case *BlockOrder_LimitPrice:
		n += proto.SizeVarint(14<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.LimitPrice)))
		n += len(x.LimitPrice)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// *
// Parameters to retrieve a previously placed block order.
type GetBlockOrderRequest struct {
	// ID for the block order assigned by the Broker.
	BlockOrderId string `protobuf:"bytes,1,opt,name=block_order_id,json=blockOrderId" json:"block_order_id,omitempty"`
}

func (m *GetBlockOrderRequest) Reset()                    { *m = GetBlockOrderRequest{} }
func (m *GetBlockOrderRequest) String() string            { return proto.CompactTextString(m) }
func (*GetBlockOrderRequest) ProtoMessage()               {}
func (*GetBlockOrderRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *GetBlockOrderRequest) GetBlockOrderId() string {
	if m != nil {
		return m.BlockOrderId
	}
	return ""
}

// *
// Representation of a retrieved block order.
type GetBlockOrderResponse struct {
	// Status of the block order.
	Status BlockOrder_BlockOrderStatus `protobuf:"varint,1,opt,name=status,enum=broker.rpc.BlockOrder_BlockOrderStatus" json:"status,omitempty"`
	// The market that the block order is for, e.g. `'BTC/LTC'`. Markets are always expressed as the combination of two common symbols, separated by a `/`.
	Market string `protobuf:"bytes,10,opt,name=market" json:"market,omitempty"`
	// The side of the market that the block order is taking.
	Side Side `protobuf:"varint,11,opt,name=side,enum=broker.rpc.Side" json:"side,omitempty"`
	// Amount, in common units for a currency (e.g. bitcoins for BTC) that is the size of the order. This field supports decimal representation of units but uses a string since protobuf lacks a decimal type (e.g. `'0.16'`)
	Amount string `protobuf:"bytes,12,opt,name=amount" json:"amount,omitempty"`
	// Types that are valid to be assigned to PriceRestriction:
	//	*GetBlockOrderResponse_IsMarketOrder
	//	*GetBlockOrderResponse_LimitPrice
	PriceRestriction isGetBlockOrderResponse_PriceRestriction `protobuf_oneof:"price_restriction"`
	// Time restriction for this block order.
	TimeInForce TimeInForce `protobuf:"varint,15,opt,name=time_in_force,json=timeInForce,enum=broker.rpc.TimeInForce" json:"time_in_force,omitempty"`
	// BlockOrder creation unix timestamp in nanoseconds
	Timestamp string `protobuf:"bytes,16,opt,name=timestamp" json:"timestamp,omitempty"`
	// BlockOrder creation ISO8601 datetime in nanoseconds
	Datetime string `protobuf:"bytes,17,opt,name=datetime" json:"datetime,omitempty"`
	// Amount of the block order that has been filled, in common units for a currency (e.g. bitcoins for BTC) represented as a decimal string (e.g. `'0.10'`)
	FillAmount string `protobuf:"bytes,20,opt,name=fill_amount,json=fillAmount" json:"fill_amount,omitempty"`
	// All orders on the SparkSwap Relayer that were placed by the Broker in support of this block order.
	Orders []*Order `protobuf:"bytes,21,rep,name=orders" json:"orders,omitempty"`
	// All fills of orders on the SparkSwap Relayer that were undertaken by the Broker in support of this block order.
	Fills []*Fill `protobuf:"bytes,22,rep,name=fills" json:"fills,omitempty"`
}

func (m *GetBlockOrderResponse) Reset()                    { *m = GetBlockOrderResponse{} }
func (m *GetBlockOrderResponse) String() string            { return proto.CompactTextString(m) }
func (*GetBlockOrderResponse) ProtoMessage()               {}
func (*GetBlockOrderResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

type isGetBlockOrderResponse_PriceRestriction interface{ isGetBlockOrderResponse_PriceRestriction() }

type GetBlockOrderResponse_IsMarketOrder struct {
	IsMarketOrder bool `protobuf:"varint,13,opt,name=is_market_order,json=isMarketOrder,oneof"`
}
type GetBlockOrderResponse_LimitPrice struct {
	LimitPrice string `protobuf:"bytes,14,opt,name=limit_price,json=limitPrice,oneof"`
}

func (*GetBlockOrderResponse_IsMarketOrder) isGetBlockOrderResponse_PriceRestriction() {}
func (*GetBlockOrderResponse_LimitPrice) isGetBlockOrderResponse_PriceRestriction()    {}

func (m *GetBlockOrderResponse) GetPriceRestriction() isGetBlockOrderResponse_PriceRestriction {
	if m != nil {
		return m.PriceRestriction
	}
	return nil
}

func (m *GetBlockOrderResponse) GetStatus() BlockOrder_BlockOrderStatus {
	if m != nil {
		return m.Status
	}
	return BlockOrder_ACTIVE
}

func (m *GetBlockOrderResponse) GetMarket() string {
	if m != nil {
		return m.Market
	}
	return ""
}

func (m *GetBlockOrderResponse) GetSide() Side {
	if m != nil {
		return m.Side
	}
	return Side_BID
}

func (m *GetBlockOrderResponse) GetAmount() string {
	if m != nil {
		return m.Amount
	}
	return ""
}

func (m *GetBlockOrderResponse) GetIsMarketOrder() bool {
	if x, ok := m.GetPriceRestriction().(*GetBlockOrderResponse_IsMarketOrder); ok {
		return x.IsMarketOrder
	}
	return false
}

func (m *GetBlockOrderResponse) GetLimitPrice() string {
	if x, ok := m.GetPriceRestriction().(*GetBlockOrderResponse_LimitPrice); ok {
		return x.LimitPrice
	}
	return ""
}

func (m *GetBlockOrderResponse) GetTimeInForce() TimeInForce {
	if m != nil {
		return m.TimeInForce
	}
	return TimeInForce_GTC
}

func (m *GetBlockOrderResponse) GetTimestamp() string {
	if m != nil {
		return m.Timestamp
	}
	return ""
}

func (m *GetBlockOrderResponse) GetDatetime() string {
	if m != nil {
		return m.Datetime
	}
	return ""
}

func (m *GetBlockOrderResponse) GetFillAmount() string {
	if m != nil {
		return m.FillAmount
	}
	return ""
}

func (m *GetBlockOrderResponse) GetOrders() []*Order {
	if m != nil {
		return m.Orders
	}
	return nil
}

func (m *GetBlockOrderResponse) GetFills() []*Fill {
	if m != nil {
		return m.Fills
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*GetBlockOrderResponse) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _GetBlockOrderResponse_OneofMarshaler, _GetBlockOrderResponse_OneofUnmarshaler, _GetBlockOrderResponse_OneofSizer, []interface{}{
		(*GetBlockOrderResponse_IsMarketOrder)(nil),
		(*GetBlockOrderResponse_LimitPrice)(nil),
	}
}

func _GetBlockOrderResponse_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*GetBlockOrderResponse)
	// price_restriction
	switch x := m.PriceRestriction.(type) {
	case *GetBlockOrderResponse_IsMarketOrder:
		t := uint64(0)
		if x.IsMarketOrder {
			t = 1
		}
		b.EncodeVarint(13<<3 | proto.WireVarint)
		b.EncodeVarint(t)
	case *GetBlockOrderResponse_LimitPrice:
		b.EncodeVarint(14<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.LimitPrice)
	case nil:
	default:
		return fmt.Errorf("GetBlockOrderResponse.PriceRestriction has unexpected type %T", x)
	}
	return nil
}

func _GetBlockOrderResponse_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*GetBlockOrderResponse)
	switch tag {
	case 13: // price_restriction.is_market_order
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.PriceRestriction = &GetBlockOrderResponse_IsMarketOrder{x != 0}
		return true, err
	case 14: // price_restriction.limit_price
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.PriceRestriction = &GetBlockOrderResponse_LimitPrice{x}
		return true, err
	default:
		return false, nil
	}
}

func _GetBlockOrderResponse_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*GetBlockOrderResponse)
	// price_restriction
	switch x := m.PriceRestriction.(type) {
	case *GetBlockOrderResponse_IsMarketOrder:
		n += proto.SizeVarint(13<<3 | proto.WireVarint)
		n += 1
	case *GetBlockOrderResponse_LimitPrice:
		n += proto.SizeVarint(14<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.LimitPrice)))
		n += len(x.LimitPrice)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// *
// Request to cancel a previously created block order.
type CancelBlockOrderRequest struct {
	// Unique ID for the block order as assigned by the Broker.
	BlockOrderId string `protobuf:"bytes,1,opt,name=block_order_id,json=blockOrderId" json:"block_order_id,omitempty"`
}

func (m *CancelBlockOrderRequest) Reset()                    { *m = CancelBlockOrderRequest{} }
func (m *CancelBlockOrderRequest) String() string            { return proto.CompactTextString(m) }
func (*CancelBlockOrderRequest) ProtoMessage()               {}
func (*CancelBlockOrderRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *CancelBlockOrderRequest) GetBlockOrderId() string {
	if m != nil {
		return m.BlockOrderId
	}
	return ""
}

// *
// All block orders in a given market.
type GetBlockOrdersResponse struct {
	// A list of all block orders in the market.
	BlockOrders []*BlockOrder `protobuf:"bytes,1,rep,name=block_orders,json=blockOrders" json:"block_orders,omitempty"`
}

func (m *GetBlockOrdersResponse) Reset()                    { *m = GetBlockOrdersResponse{} }
func (m *GetBlockOrdersResponse) String() string            { return proto.CompactTextString(m) }
func (*GetBlockOrdersResponse) ProtoMessage()               {}
func (*GetBlockOrdersResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *GetBlockOrdersResponse) GetBlockOrders() []*BlockOrder {
	if m != nil {
		return m.BlockOrders
	}
	return nil
}

// *
// Request to retrieve all block orders in a given market.
type GetBlockOrdersRequest struct {
	// Market for which to retrieve block orders, expressed as a string separating two common symbols with a '/', e.g. `'BTC/LTC'`
	Market string `protobuf:"bytes,1,opt,name=market" json:"market,omitempty"`
}

func (m *GetBlockOrdersRequest) Reset()                    { *m = GetBlockOrdersRequest{} }
func (m *GetBlockOrdersRequest) String() string            { return proto.CompactTextString(m) }
func (*GetBlockOrdersRequest) ProtoMessage()               {}
func (*GetBlockOrdersRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *GetBlockOrdersRequest) GetMarket() string {
	if m != nil {
		return m.Market
	}
	return ""
}

// *
// Request for updates in a given market.
type WatchMarketRequest struct {
	// Market to retrieve updates for, e.g. `'BTC/LTC'`.
	Market string `protobuf:"bytes,1,opt,name=market" json:"market,omitempty"`
}

func (m *WatchMarketRequest) Reset()                    { *m = WatchMarketRequest{} }
func (m *WatchMarketRequest) String() string            { return proto.CompactTextString(m) }
func (*WatchMarketRequest) ProtoMessage()               {}
func (*WatchMarketRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *WatchMarketRequest) GetMarket() string {
	if m != nil {
		return m.Market
	}
	return ""
}

// *
// An update to the watched market.
type WatchMarketResponse struct {
	// Type of event this update is.
	Type WatchMarketResponse_EventType `protobuf:"varint,1,opt,name=type,enum=broker.rpc.WatchMarketResponse_EventType" json:"type,omitempty"`
	// The market update
	MarketEvent *MarketEvent `protobuf:"bytes,2,opt,name=market_event,json=marketEvent" json:"market_event,omitempty"`
}

func (m *WatchMarketResponse) Reset()                    { *m = WatchMarketResponse{} }
func (m *WatchMarketResponse) String() string            { return proto.CompactTextString(m) }
func (*WatchMarketResponse) ProtoMessage()               {}
func (*WatchMarketResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *WatchMarketResponse) GetType() WatchMarketResponse_EventType {
	if m != nil {
		return m.Type
	}
	return WatchMarketResponse_ADD
}

func (m *WatchMarketResponse) GetMarketEvent() *MarketEvent {
	if m != nil {
		return m.MarketEvent
	}
	return nil
}

// *
// Market events are events that change the orderbook for a given market. The are a combination of orders, fills, and cancels.
type MarketEvent struct {
	// The Relayer-assigned ID of the underlying order
	OrderId string `protobuf:"bytes,1,opt,name=order_id,json=orderId" json:"order_id,omitempty"`
	// Amount of the order expressed in a decimal string of common units for a currency (e.g. bitcoins for BTC).
	Amount string `protobuf:"bytes,2,opt,name=amount" json:"amount,omitempty"`
	// Price at which the order was placed, expressed as a decimal string ratio between the common units of the currencies (e.g. litecoins to bitcoins, not litoshis to satoshis). All orders on the SparkSwap Relayer have prices.
	Price string `protobuf:"bytes,3,opt,name=price" json:"price,omitempty"`
	// Side that the order is taking
	Side Side `protobuf:"varint,4,opt,name=side,enum=broker.rpc.Side" json:"side,omitempty"`
}

func (m *MarketEvent) Reset()                    { *m = MarketEvent{} }
func (m *MarketEvent) String() string            { return proto.CompactTextString(m) }
func (*MarketEvent) ProtoMessage()               {}
func (*MarketEvent) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *MarketEvent) GetOrderId() string {
	if m != nil {
		return m.OrderId
	}
	return ""
}

func (m *MarketEvent) GetAmount() string {
	if m != nil {
		return m.Amount
	}
	return ""
}

func (m *MarketEvent) GetPrice() string {
	if m != nil {
		return m.Price
	}
	return ""
}

func (m *MarketEvent) GetSide() Side {
	if m != nil {
		return m.Side
	}
	return Side_BID
}

type GetOrderbookRequest struct {
	// Market to retrieve updates for, e.g. `'BTC/LTC'`.
	Market string `protobuf:"bytes,1,opt,name=market" json:"market,omitempty"`
}

func (m *GetOrderbookRequest) Reset()                    { *m = GetOrderbookRequest{} }
func (m *GetOrderbookRequest) String() string            { return proto.CompactTextString(m) }
func (*GetOrderbookRequest) ProtoMessage()               {}
func (*GetOrderbookRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

func (m *GetOrderbookRequest) GetMarket() string {
	if m != nil {
		return m.Market
	}
	return ""
}

type Bid struct {
	// price of the bid
	Price string `protobuf:"bytes,1,opt,name=price" json:"price,omitempty"`
	// amount to be bought
	Amount string `protobuf:"bytes,2,opt,name=amount" json:"amount,omitempty"`
}

func (m *Bid) Reset()                    { *m = Bid{} }
func (m *Bid) String() string            { return proto.CompactTextString(m) }
func (*Bid) ProtoMessage()               {}
func (*Bid) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

func (m *Bid) GetPrice() string {
	if m != nil {
		return m.Price
	}
	return ""
}

func (m *Bid) GetAmount() string {
	if m != nil {
		return m.Amount
	}
	return ""
}

type Ask struct {
	// price of the ask
	Price string `protobuf:"bytes,1,opt,name=price" json:"price,omitempty"`
	// amount to be sold
	Amount string `protobuf:"bytes,2,opt,name=amount" json:"amount,omitempty"`
}

func (m *Ask) Reset()                    { *m = Ask{} }
func (m *Ask) String() string            { return proto.CompactTextString(m) }
func (*Ask) ProtoMessage()               {}
func (*Ask) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{18} }

func (m *Ask) GetPrice() string {
	if m != nil {
		return m.Price
	}
	return ""
}

func (m *Ask) GetAmount() string {
	if m != nil {
		return m.Amount
	}
	return ""
}

// *
// Contains information about bids and asks on the orderbook
type GetOrderbookResponse struct {
	// list of bids on the orderbook in the current state
	Bids []*Bid `protobuf:"bytes,1,rep,name=bids" json:"bids,omitempty"`
	// list of asks on the orderbook in the current state
	Asks []*Ask `protobuf:"bytes,2,rep,name=asks" json:"asks,omitempty"`
	// time in milliseconds of generation time of the orderbook (when the call was made)
	Timestamp int64 `protobuf:"varint,3,opt,name=timestamp" json:"timestamp,omitempty"`
	// time the last entry that was added (ISO8601 datetime string)
	Datetime string `protobuf:"bytes,4,opt,name=datetime" json:"datetime,omitempty"`
}

func (m *GetOrderbookResponse) Reset()                    { *m = GetOrderbookResponse{} }
func (m *GetOrderbookResponse) String() string            { return proto.CompactTextString(m) }
func (*GetOrderbookResponse) ProtoMessage()               {}
func (*GetOrderbookResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{19} }

func (m *GetOrderbookResponse) GetBids() []*Bid {
	if m != nil {
		return m.Bids
	}
	return nil
}

func (m *GetOrderbookResponse) GetAsks() []*Ask {
	if m != nil {
		return m.Asks
	}
	return nil
}

func (m *GetOrderbookResponse) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *GetOrderbookResponse) GetDatetime() string {
	if m != nil {
		return m.Datetime
	}
	return ""
}

// *
// Request for a new address to send funds to for a given currency.
type NewDepositAddressRequest struct {
	// Currency for which to generate the address
	Symbol Symbol `protobuf:"varint,1,opt,name=symbol,enum=broker.rpc.Symbol" json:"symbol,omitempty"`
}

func (m *NewDepositAddressRequest) Reset()                    { *m = NewDepositAddressRequest{} }
func (m *NewDepositAddressRequest) String() string            { return proto.CompactTextString(m) }
func (*NewDepositAddressRequest) ProtoMessage()               {}
func (*NewDepositAddressRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{20} }

func (m *NewDepositAddressRequest) GetSymbol() Symbol {
	if m != nil {
		return m.Symbol
	}
	return Symbol_BTC
}

// *
// Created deposit address for a given currency.
type NewDepositAddressResponse struct {
	// Address created.
	Address string `protobuf:"bytes,1,opt,name=address" json:"address,omitempty"`
}

func (m *NewDepositAddressResponse) Reset()                    { *m = NewDepositAddressResponse{} }
func (m *NewDepositAddressResponse) String() string            { return proto.CompactTextString(m) }
func (*NewDepositAddressResponse) ProtoMessage()               {}
func (*NewDepositAddressResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{21} }

func (m *NewDepositAddressResponse) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

// *
// Balance in a currency in terms of what is committed in channels and total balance in wallets managed by this node.
type Balance struct {
	// Currency of the balance.
	Symbol string `protobuf:"bytes,1,opt,name=symbol" json:"symbol,omitempty"`
	// Total balance of the wallets managed by this node in this currency, including balance in channels. This is currently in common units (e.g. 0.5 BTC)
	UncommittedBalance string `protobuf:"bytes,2,opt,name=uncommitted_balance,json=uncommittedBalance" json:"uncommitted_balance,omitempty"`
	// Balance in the listed currency that is currently in channels. This is currently in common units (e.g. 0.5 BTC)
	TotalChannelBalance string `protobuf:"bytes,3,opt,name=total_channel_balance,json=totalChannelBalance" json:"total_channel_balance,omitempty"`
	// Balance in the listed currency that is currently in pending channels. This is currently in common units (e.g. 0.5 BTC)
	TotalPendingChannelBalance string `protobuf:"bytes,4,opt,name=total_pending_channel_balance,json=totalPendingChannelBalance" json:"total_pending_channel_balance,omitempty"`
	// Balance in the listed currency that is currently in pending closing channels and unconfirmed wallet balance. This is currently in common units (e.g. 0.5 BTC)
	UncommittedPendingBalance string `protobuf:"bytes,5,opt,name=uncommitted_pending_balance,json=uncommittedPendingBalance" json:"uncommitted_pending_balance,omitempty"`
	// Error message if balances are not available
	Error string `protobuf:"bytes,10,opt,name=error" json:"error,omitempty"`
}

func (m *Balance) Reset()                    { *m = Balance{} }
func (m *Balance) String() string            { return proto.CompactTextString(m) }
func (*Balance) ProtoMessage()               {}
func (*Balance) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{22} }

func (m *Balance) GetSymbol() string {
	if m != nil {
		return m.Symbol
	}
	return ""
}

func (m *Balance) GetUncommittedBalance() string {
	if m != nil {
		return m.UncommittedBalance
	}
	return ""
}

func (m *Balance) GetTotalChannelBalance() string {
	if m != nil {
		return m.TotalChannelBalance
	}
	return ""
}

func (m *Balance) GetTotalPendingChannelBalance() string {
	if m != nil {
		return m.TotalPendingChannelBalance
	}
	return ""
}

func (m *Balance) GetUncommittedPendingBalance() string {
	if m != nil {
		return m.UncommittedPendingBalance
	}
	return ""
}

func (m *Balance) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

// *
// All balances for a Broker.
type GetBalancesResponse struct {
	// Balances in all currencies available to this Broker.
	Balances []*Balance `protobuf:"bytes,1,rep,name=balances" json:"balances,omitempty"`
}

func (m *GetBalancesResponse) Reset()                    { *m = GetBalancesResponse{} }
func (m *GetBalancesResponse) String() string            { return proto.CompactTextString(m) }
func (*GetBalancesResponse) ProtoMessage()               {}
func (*GetBalancesResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{23} }

func (m *GetBalancesResponse) GetBalances() []*Balance {
	if m != nil {
		return m.Balances
	}
	return nil
}

// *
// Local and remote balances in the listed currency in the active, pending and inactive channels.
type Capacity struct {
	// Currency of the balance.
	Symbol string `protobuf:"bytes,1,opt,name=symbol" json:"symbol,omitempty"`
	// Total pending amount a user can send in the currency. This is currently in common units (e.g. 0.15 BTC)
	PendingSendCapacity string `protobuf:"bytes,4,opt,name=pending_send_capacity,json=pendingSendCapacity" json:"pending_send_capacity,omitempty"`
	// Total pending amount a user can receive in the currency. This is currently in common units (e.g. 0.15 BTC)
	PendingReceiveCapacity string `protobuf:"bytes,5,opt,name=pending_receive_capacity,json=pendingReceiveCapacity" json:"pending_receive_capacity,omitempty"`
	// Total inactive amount a user can send in the currency. This is currently in common units (e.g. 0.15 BTC)
	InactiveSendCapacity string `protobuf:"bytes,6,opt,name=inactive_send_capacity,json=inactiveSendCapacity" json:"inactive_send_capacity,omitempty"`
	// Total inactive amount a user can send in the currency. This is currently in common units (e.g. 0.15 BTC)
	InactiveReceiveCapacity string `protobuf:"bytes,7,opt,name=inactive_receive_capacity,json=inactiveReceiveCapacity" json:"inactive_receive_capacity,omitempty"`
	// Total available amount a user can send in the currency. This is currently in common units (e.g. 0.15 BTC)
	AvailableSendCapacity string `protobuf:"bytes,8,opt,name=available_send_capacity,json=availableSendCapacity" json:"available_send_capacity,omitempty"`
	// Total available amount a user can send in the currency. This is currently in common units (e.g. 0.15 BTC)
	AvailableReceiveCapacity string `protobuf:"bytes,9,opt,name=available_receive_capacity,json=availableReceiveCapacity" json:"available_receive_capacity,omitempty"`
	// Total inbound outstanding amount. This is currently in common units (e.g. 0.15 BTC)
	OutstandingSendCapacity string `protobuf:"bytes,10,opt,name=outstanding_send_capacity,json=outstandingSendCapacity" json:"outstanding_send_capacity,omitempty"`
	// Total outbound outstanding amount. This is currently in common units (e.g. 0.15 BTC)
	OutstandingReceiveCapacity string `protobuf:"bytes,11,opt,name=outstanding_receive_capacity,json=outstandingReceiveCapacity" json:"outstanding_receive_capacity,omitempty"`
	// Status of capacities. OK for success or FAILED if an error occurred when requesting capacities
	Status string `protobuf:"bytes,20,opt,name=status" json:"status,omitempty"`
	// Error message if status is FAILED
	Error string `protobuf:"bytes,21,opt,name=error" json:"error,omitempty"`
}

func (m *Capacity) Reset()                    { *m = Capacity{} }
func (m *Capacity) String() string            { return proto.CompactTextString(m) }
func (*Capacity) ProtoMessage()               {}
func (*Capacity) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{24} }

func (m *Capacity) GetSymbol() string {
	if m != nil {
		return m.Symbol
	}
	return ""
}

func (m *Capacity) GetPendingSendCapacity() string {
	if m != nil {
		return m.PendingSendCapacity
	}
	return ""
}

func (m *Capacity) GetPendingReceiveCapacity() string {
	if m != nil {
		return m.PendingReceiveCapacity
	}
	return ""
}

func (m *Capacity) GetInactiveSendCapacity() string {
	if m != nil {
		return m.InactiveSendCapacity
	}
	return ""
}

func (m *Capacity) GetInactiveReceiveCapacity() string {
	if m != nil {
		return m.InactiveReceiveCapacity
	}
	return ""
}

func (m *Capacity) GetAvailableSendCapacity() string {
	if m != nil {
		return m.AvailableSendCapacity
	}
	return ""
}

func (m *Capacity) GetAvailableReceiveCapacity() string {
	if m != nil {
		return m.AvailableReceiveCapacity
	}
	return ""
}

func (m *Capacity) GetOutstandingSendCapacity() string {
	if m != nil {
		return m.OutstandingSendCapacity
	}
	return ""
}

func (m *Capacity) GetOutstandingReceiveCapacity() string {
	if m != nil {
		return m.OutstandingReceiveCapacity
	}
	return ""
}

func (m *Capacity) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *Capacity) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

// *
// Trading capacities for the base and counter currencies for a given market.
type GetTradingCapacitiesResponse struct {
	// local and remote capacities in active, pending and inactive channels for the base currency
	BaseSymbolCapacities *Capacity `protobuf:"bytes,1,opt,name=base_symbol_capacities,json=baseSymbolCapacities" json:"base_symbol_capacities,omitempty"`
	// local and remote capacities in active, pending and inactive channels for the counter currency
	CounterSymbolCapacities *Capacity `protobuf:"bytes,2,opt,name=counter_symbol_capacities,json=counterSymbolCapacities" json:"counter_symbol_capacities,omitempty"`
}

func (m *GetTradingCapacitiesResponse) Reset()                    { *m = GetTradingCapacitiesResponse{} }
func (m *GetTradingCapacitiesResponse) String() string            { return proto.CompactTextString(m) }
func (*GetTradingCapacitiesResponse) ProtoMessage()               {}
func (*GetTradingCapacitiesResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{25} }

func (m *GetTradingCapacitiesResponse) GetBaseSymbolCapacities() *Capacity {
	if m != nil {
		return m.BaseSymbolCapacities
	}
	return nil
}

func (m *GetTradingCapacitiesResponse) GetCounterSymbolCapacities() *Capacity {
	if m != nil {
		return m.CounterSymbolCapacities
	}
	return nil
}

// *
// Request to retrieve local and remote capacities in active, pending and inactive channels for a given market
type GetTradingCapacitiesRequest struct {
	// Name of the market to retrieve capacities for
	Market string `protobuf:"bytes,1,opt,name=market" json:"market,omitempty"`
}

func (m *GetTradingCapacitiesRequest) Reset()                    { *m = GetTradingCapacitiesRequest{} }
func (m *GetTradingCapacitiesRequest) String() string            { return proto.CompactTextString(m) }
func (*GetTradingCapacitiesRequest) ProtoMessage()               {}
func (*GetTradingCapacitiesRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{26} }

func (m *GetTradingCapacitiesRequest) GetMarket() string {
	if m != nil {
		return m.Market
	}
	return ""
}

// *
// Request to commit an amount of a given currency on a given market.
type CommitRequest struct {
	// Currency of the balance to commit.
	Symbol Symbol `protobuf:"varint,1,opt,name=symbol,enum=broker.rpc.Symbol" json:"symbol,omitempty"`
	// Amount of the currency to commit. This is currently in common units (e.g. 0.5 BTC)
	Balance string `protobuf:"bytes,2,opt,name=balance" json:"balance,omitempty"`
	// Market to commit the amount in currency to. e.g. BTC/LTC
	Market string `protobuf:"bytes,3,opt,name=market" json:"market,omitempty"`
}

func (m *CommitRequest) Reset()                    { *m = CommitRequest{} }
func (m *CommitRequest) String() string            { return proto.CompactTextString(m) }
func (*CommitRequest) ProtoMessage()               {}
func (*CommitRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{27} }

func (m *CommitRequest) GetSymbol() Symbol {
	if m != nil {
		return m.Symbol
	}
	return Symbol_BTC
}

func (m *CommitRequest) GetBalance() string {
	if m != nil {
		return m.Balance
	}
	return ""
}

func (m *CommitRequest) GetMarket() string {
	if m != nil {
		return m.Market
	}
	return ""
}

// *
// Request to close channels currently open on the given market
type ReleaseChannelsRequest struct {
	// Market to close channels on
	Market string `protobuf:"bytes,1,opt,name=market" json:"market,omitempty"`
	// Force channels (active, inactive and pending) to close, which may result in funds being locked for additional time and fees
	Force bool `protobuf:"varint,2,opt,name=force" json:"force,omitempty"`
}

func (m *ReleaseChannelsRequest) Reset()                    { *m = ReleaseChannelsRequest{} }
func (m *ReleaseChannelsRequest) String() string            { return proto.CompactTextString(m) }
func (*ReleaseChannelsRequest) ProtoMessage()               {}
func (*ReleaseChannelsRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{28} }

func (m *ReleaseChannelsRequest) GetMarket() string {
	if m != nil {
		return m.Market
	}
	return ""
}

func (m *ReleaseChannelsRequest) GetForce() bool {
	if m != nil {
		return m.Force
	}
	return false
}

// *
// Container for channel information for a specific currency on a given market
type ReleasedCurrency struct {
	// Currency of the information
	Symbol string `protobuf:"bytes,1,opt,name=symbol" json:"symbol,omitempty"`
	// Status of the channel. e.g. RELEASED or FAILED
	Status string `protobuf:"bytes,2,opt,name=status" json:"status,omitempty"`
	// Message that identifies an issue with a released channel. Only available if status of channel is not `RELEASED`
	Error string `protobuf:"bytes,10,opt,name=error" json:"error,omitempty"`
}

func (m *ReleasedCurrency) Reset()                    { *m = ReleasedCurrency{} }
func (m *ReleasedCurrency) String() string            { return proto.CompactTextString(m) }
func (*ReleasedCurrency) ProtoMessage()               {}
func (*ReleasedCurrency) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{29} }

func (m *ReleasedCurrency) GetSymbol() string {
	if m != nil {
		return m.Symbol
	}
	return ""
}

func (m *ReleasedCurrency) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *ReleasedCurrency) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

type ReleaseChannelsResponse struct {
	// Channel status information for the base currency
	Base *ReleasedCurrency `protobuf:"bytes,1,opt,name=base" json:"base,omitempty"`
	// Channel status information for the counter currency
	Counter *ReleasedCurrency `protobuf:"bytes,2,opt,name=counter" json:"counter,omitempty"`
}

func (m *ReleaseChannelsResponse) Reset()                    { *m = ReleaseChannelsResponse{} }
func (m *ReleaseChannelsResponse) String() string            { return proto.CompactTextString(m) }
func (*ReleaseChannelsResponse) ProtoMessage()               {}
func (*ReleaseChannelsResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{30} }

func (m *ReleaseChannelsResponse) GetBase() *ReleasedCurrency {
	if m != nil {
		return m.Base
	}
	return nil
}

func (m *ReleaseChannelsResponse) GetCounter() *ReleasedCurrency {
	if m != nil {
		return m.Counter
	}
	return nil
}

// *
// Get the payment channel network address for a given currency.
type GetPaymentChannelNetworkAddressRequest struct {
	// Currency for which to retrieve the address
	Symbol Symbol `protobuf:"varint,1,opt,name=symbol,enum=broker.rpc.Symbol" json:"symbol,omitempty"`
}

func (m *GetPaymentChannelNetworkAddressRequest) Reset() {
	*m = GetPaymentChannelNetworkAddressRequest{}
}
func (m *GetPaymentChannelNetworkAddressRequest) String() string { return proto.CompactTextString(m) }
func (*GetPaymentChannelNetworkAddressRequest) ProtoMessage()    {}
func (*GetPaymentChannelNetworkAddressRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{31}
}

func (m *GetPaymentChannelNetworkAddressRequest) GetSymbol() Symbol {
	if m != nil {
		return m.Symbol
	}
	return Symbol_BTC
}

// *
// Created deposit address for a given currency.
type GetPaymentChannelNetworkAddressResponse struct {
	// Network Address retrieved
	PaymentChannelNetworkAddress string `protobuf:"bytes,1,opt,name=payment_channel_network_address,json=paymentChannelNetworkAddress" json:"payment_channel_network_address,omitempty"`
}

func (m *GetPaymentChannelNetworkAddressResponse) Reset() {
	*m = GetPaymentChannelNetworkAddressResponse{}
}
func (m *GetPaymentChannelNetworkAddressResponse) String() string { return proto.CompactTextString(m) }
func (*GetPaymentChannelNetworkAddressResponse) ProtoMessage()    {}
func (*GetPaymentChannelNetworkAddressResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{32}
}

func (m *GetPaymentChannelNetworkAddressResponse) GetPaymentChannelNetworkAddress() string {
	if m != nil {
		return m.PaymentChannelNetworkAddress
	}
	return ""
}

// *
// Request to withdraw funds from wallet to specified address
type WithdrawFundsRequest struct {
	// Currency of funds to withdraw
	Symbol Symbol `protobuf:"varint,1,opt,name=symbol,enum=broker.rpc.Symbol" json:"symbol,omitempty"`
	// Amount of funds to withdraw
	Amount string `protobuf:"bytes,2,opt,name=amount" json:"amount,omitempty"`
	// Address to send the funds to
	Address string `protobuf:"bytes,3,opt,name=address" json:"address,omitempty"`
}

func (m *WithdrawFundsRequest) Reset()                    { *m = WithdrawFundsRequest{} }
func (m *WithdrawFundsRequest) String() string            { return proto.CompactTextString(m) }
func (*WithdrawFundsRequest) ProtoMessage()               {}
func (*WithdrawFundsRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{33} }

func (m *WithdrawFundsRequest) GetSymbol() Symbol {
	if m != nil {
		return m.Symbol
	}
	return Symbol_BTC
}

func (m *WithdrawFundsRequest) GetAmount() string {
	if m != nil {
		return m.Amount
	}
	return ""
}

func (m *WithdrawFundsRequest) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

type WithdrawFundsResponse struct {
	// transaction id of the withdrawal
	Txid string `protobuf:"bytes,1,opt,name=txid" json:"txid,omitempty"`
}

func (m *WithdrawFundsResponse) Reset()                    { *m = WithdrawFundsResponse{} }
func (m *WithdrawFundsResponse) String() string            { return proto.CompactTextString(m) }
func (*WithdrawFundsResponse) ProtoMessage()               {}
func (*WithdrawFundsResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{34} }

func (m *WithdrawFundsResponse) GetTxid() string {
	if m != nil {
		return m.Txid
	}
	return ""
}

// *
// Request to create a wallet for a specific currency
type CreateWalletRequest struct {
	// Currency of wallet
	Symbol string `protobuf:"bytes,1,opt,name=symbol" json:"symbol,omitempty"`
	// Password for the wallet
	Password string `protobuf:"bytes,2,opt,name=password" json:"password,omitempty"`
}

func (m *CreateWalletRequest) Reset()                    { *m = CreateWalletRequest{} }
func (m *CreateWalletRequest) String() string            { return proto.CompactTextString(m) }
func (*CreateWalletRequest) ProtoMessage()               {}
func (*CreateWalletRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{35} }

func (m *CreateWalletRequest) GetSymbol() string {
	if m != nil {
		return m.Symbol
	}
	return ""
}

func (m *CreateWalletRequest) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

// *
// CreateWallet response that contains wallet backup information.
//
// The returned array is a recovery seed that a broker can use to recover funds
// from their crypto wallet in the cause of fatal error or loss of data.
//
// The information returned from this response should be kept private, as any user
// could potentially use this info to steal your on-chain funds.
//
// When this information is returned, make sure to write it down and store it
// in a safe place.
type CreateWalletResponse struct {
	// 24 length Array of recovery seed words
	RecoverySeed []string `protobuf:"bytes,1,rep,name=recovery_seed,json=recoverySeed" json:"recovery_seed,omitempty"`
}

func (m *CreateWalletResponse) Reset()                    { *m = CreateWalletResponse{} }
func (m *CreateWalletResponse) String() string            { return proto.CompactTextString(m) }
func (*CreateWalletResponse) ProtoMessage()               {}
func (*CreateWalletResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{36} }

func (m *CreateWalletResponse) GetRecoverySeed() []string {
	if m != nil {
		return m.RecoverySeed
	}
	return nil
}

// *
// Request to unlock a wallet for a specific currency
type UnlockWalletRequest struct {
	// Currency of wallet
	Symbol string `protobuf:"bytes,1,opt,name=symbol" json:"symbol,omitempty"`
	// Password for the wallet
	Password string `protobuf:"bytes,2,opt,name=password" json:"password,omitempty"`
}

func (m *UnlockWalletRequest) Reset()                    { *m = UnlockWalletRequest{} }
func (m *UnlockWalletRequest) String() string            { return proto.CompactTextString(m) }
func (*UnlockWalletRequest) ProtoMessage()               {}
func (*UnlockWalletRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{37} }

func (m *UnlockWalletRequest) GetSymbol() string {
	if m != nil {
		return m.Symbol
	}
	return ""
}

func (m *UnlockWalletRequest) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

// *
// Supported markets expose all relevant information about a market that is supported by sparkswap
type SupportedMarket struct {
	// unique id for the market
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	// symbol of the market. e.g. `BTC/LTC`
	Symbol string `protobuf:"bytes,2,opt,name=symbol" json:"symbol,omitempty"`
	// symbol of base currency
	Base string `protobuf:"bytes,3,opt,name=base" json:"base,omitempty"`
	// symbol of counter currency
	Counter string `protobuf:"bytes,4,opt,name=counter" json:"counter,omitempty"`
	// if the market is active or not
	Active bool `protobuf:"varint,5,opt,name=active" json:"active,omitempty"`
}

func (m *SupportedMarket) Reset()                    { *m = SupportedMarket{} }
func (m *SupportedMarket) String() string            { return proto.CompactTextString(m) }
func (*SupportedMarket) ProtoMessage()               {}
func (*SupportedMarket) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{38} }

func (m *SupportedMarket) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *SupportedMarket) GetSymbol() string {
	if m != nil {
		return m.Symbol
	}
	return ""
}

func (m *SupportedMarket) GetBase() string {
	if m != nil {
		return m.Base
	}
	return ""
}

func (m *SupportedMarket) GetCounter() string {
	if m != nil {
		return m.Counter
	}
	return ""
}

func (m *SupportedMarket) GetActive() bool {
	if m != nil {
		return m.Active
	}
	return false
}

// *
// Contains information about all supported markets on sparkswap
type GetSupportedMarketsResponse struct {
	// a list of all supported markets on sparkswap
	SupportedMarkets []*SupportedMarket `protobuf:"bytes,1,rep,name=supported_markets,json=supportedMarkets" json:"supported_markets,omitempty"`
}

func (m *GetSupportedMarketsResponse) Reset()                    { *m = GetSupportedMarketsResponse{} }
func (m *GetSupportedMarketsResponse) String() string            { return proto.CompactTextString(m) }
func (*GetSupportedMarketsResponse) ProtoMessage()               {}
func (*GetSupportedMarketsResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{39} }

func (m *GetSupportedMarketsResponse) GetSupportedMarkets() []*SupportedMarket {
	if m != nil {
		return m.SupportedMarkets
	}
	return nil
}

type GetMarketStatsRequest struct {
	// Market to commit the amount in currency to. e.g. `BTC/LTC`
	Market string `protobuf:"bytes,1,opt,name=market" json:"market,omitempty"`
}

func (m *GetMarketStatsRequest) Reset()                    { *m = GetMarketStatsRequest{} }
func (m *GetMarketStatsRequest) String() string            { return proto.CompactTextString(m) }
func (*GetMarketStatsRequest) ProtoMessage()               {}
func (*GetMarketStatsRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{40} }

func (m *GetMarketStatsRequest) GetMarket() string {
	if m != nil {
		return m.Market
	}
	return ""
}

type GetMarketStatsResponse struct {
	// symbol of the market. e.g. `BTC/LTC`
	Symbol string `protobuf:"bytes,1,opt,name=symbol" json:"symbol,omitempty"`
	// 64-bit Unix nano-second timestamp
	Timestamp int64 `protobuf:"varint,2,opt,name=timestamp" json:"timestamp,omitempty"`
	// ISO8601 datetime string (nano-seconds)
	Datetime string `protobuf:"bytes,3,opt,name=datetime" json:"datetime,omitempty"`
	// highest price in past 24 hours
	High string `protobuf:"bytes,4,opt,name=high" json:"high,omitempty"`
	// lowest price in past 24 hours
	Low string `protobuf:"bytes,5,opt,name=low" json:"low,omitempty"`
	// current best bid
	Bid string `protobuf:"bytes,6,opt,name=bid" json:"bid,omitempty"`
	// current best bid's amount
	BidVolume string `protobuf:"bytes,7,opt,name=bidVolume" json:"bidVolume,omitempty"`
	// current best ask
	Ask string `protobuf:"bytes,8,opt,name=ask" json:"ask,omitempty"`
	// current best ask's amount
	AskVolume string `protobuf:"bytes,9,opt,name=askVolume" json:"askVolume,omitempty"`
	// volume weighed average price (vwap) for the past 24 hours
	Vwap string `protobuf:"bytes,10,opt,name=vwap" json:"vwap,omitempty"`
	// volume of base currency in past 24 hours
	BaseVolume string `protobuf:"bytes,11,opt,name=baseVolume" json:"baseVolume,omitempty"`
	// volume of counter (quote) currency in past 24 hours
	CounterVolume string `protobuf:"bytes,12,opt,name=counterVolume" json:"counterVolume,omitempty"`
}

func (m *GetMarketStatsResponse) Reset()                    { *m = GetMarketStatsResponse{} }
func (m *GetMarketStatsResponse) String() string            { return proto.CompactTextString(m) }
func (*GetMarketStatsResponse) ProtoMessage()               {}
func (*GetMarketStatsResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{41} }

func (m *GetMarketStatsResponse) GetSymbol() string {
	if m != nil {
		return m.Symbol
	}
	return ""
}

func (m *GetMarketStatsResponse) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *GetMarketStatsResponse) GetDatetime() string {
	if m != nil {
		return m.Datetime
	}
	return ""
}

func (m *GetMarketStatsResponse) GetHigh() string {
	if m != nil {
		return m.High
	}
	return ""
}

func (m *GetMarketStatsResponse) GetLow() string {
	if m != nil {
		return m.Low
	}
	return ""
}

func (m *GetMarketStatsResponse) GetBid() string {
	if m != nil {
		return m.Bid
	}
	return ""
}

func (m *GetMarketStatsResponse) GetBidVolume() string {
	if m != nil {
		return m.BidVolume
	}
	return ""
}

func (m *GetMarketStatsResponse) GetAsk() string {
	if m != nil {
		return m.Ask
	}
	return ""
}

func (m *GetMarketStatsResponse) GetAskVolume() string {
	if m != nil {
		return m.AskVolume
	}
	return ""
}

func (m *GetMarketStatsResponse) GetVwap() string {
	if m != nil {
		return m.Vwap
	}
	return ""
}

func (m *GetMarketStatsResponse) GetBaseVolume() string {
	if m != nil {
		return m.BaseVolume
	}
	return ""
}

func (m *GetMarketStatsResponse) GetCounterVolume() string {
	if m != nil {
		return m.CounterVolume
	}
	return ""
}

// *
// Parameters to retrieve a list of trades within a specified time frame on a given market
type GetTradesRequest struct {
	// Market to retrieve updates for, e.g. `'BTC/LTC'`.
	Market string `protobuf:"bytes,1,opt,name=market" json:"market,omitempty"`
	// Starting date for the results. ISO8601
	Since string `protobuf:"bytes,2,opt,name=since" json:"since,omitempty"`
	// int64 number to limit results
	Limit int64 `protobuf:"varint,3,opt,name=limit" json:"limit,omitempty"`
}

func (m *GetTradesRequest) Reset()                    { *m = GetTradesRequest{} }
func (m *GetTradesRequest) String() string            { return proto.CompactTextString(m) }
func (*GetTradesRequest) ProtoMessage()               {}
func (*GetTradesRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{42} }

func (m *GetTradesRequest) GetMarket() string {
	if m != nil {
		return m.Market
	}
	return ""
}

func (m *GetTradesRequest) GetSince() string {
	if m != nil {
		return m.Since
	}
	return ""
}

func (m *GetTradesRequest) GetLimit() int64 {
	if m != nil {
		return m.Limit
	}
	return 0
}

// *
// Trade exposes all relevant information about a filled order
type Trade struct {
	// id of the trade
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	// Trade creation unix timestamp in nanoseconds
	Timestamp string `protobuf:"bytes,2,opt,name=timestamp" json:"timestamp,omitempty"`
	// Trade creation ISO8601 datetime in nanoseconds
	Datetime string `protobuf:"bytes,3,opt,name=datetime" json:"datetime,omitempty"`
	// order id
	Order string `protobuf:"bytes,4,opt,name=order" json:"order,omitempty"`
	// market name the trade was executed on e.g. BTC/LTC
	Market string `protobuf:"bytes,5,opt,name=market" json:"market,omitempty"`
	// order type, 'market', 'limit' or undefined/None/null
	Type string `protobuf:"bytes,6,opt,name=type" json:"type,omitempty"`
	// direction of the trade, 'buy' or 'sell'
	Side string `protobuf:"bytes,7,opt,name=side" json:"side,omitempty"`
	// float price in quote currency
	Price string `protobuf:"bytes,8,opt,name=price" json:"price,omitempty"`
	// amount of base currency
	Amount string `protobuf:"bytes,9,opt,name=amount" json:"amount,omitempty"`
}

func (m *Trade) Reset()                    { *m = Trade{} }
func (m *Trade) String() string            { return proto.CompactTextString(m) }
func (*Trade) ProtoMessage()               {}
func (*Trade) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{43} }

func (m *Trade) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Trade) GetTimestamp() string {
	if m != nil {
		return m.Timestamp
	}
	return ""
}

func (m *Trade) GetDatetime() string {
	if m != nil {
		return m.Datetime
	}
	return ""
}

func (m *Trade) GetOrder() string {
	if m != nil {
		return m.Order
	}
	return ""
}

func (m *Trade) GetMarket() string {
	if m != nil {
		return m.Market
	}
	return ""
}

func (m *Trade) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *Trade) GetSide() string {
	if m != nil {
		return m.Side
	}
	return ""
}

func (m *Trade) GetPrice() string {
	if m != nil {
		return m.Price
	}
	return ""
}

func (m *Trade) GetAmount() string {
	if m != nil {
		return m.Amount
	}
	return ""
}

// *
// Contains information about all trades on sparkswap
type GetTradesResponse struct {
	Trades []*Trade `protobuf:"bytes,1,rep,name=trades" json:"trades,omitempty"`
}

func (m *GetTradesResponse) Reset()                    { *m = GetTradesResponse{} }
func (m *GetTradesResponse) String() string            { return proto.CompactTextString(m) }
func (*GetTradesResponse) ProtoMessage()               {}
func (*GetTradesResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{44} }

func (m *GetTradesResponse) GetTrades() []*Trade {
	if m != nil {
		return m.Trades
	}
	return nil
}

func init() {
	proto.RegisterType((*Google)(nil), "broker.rpc.google")
	proto.RegisterType((*GoogleProtobuf)(nil), "broker.rpc.google.protobuf")
	proto.RegisterType((*GoogleProtobuf_Empty)(nil), "broker.rpc.google.protobuf.Empty")
	proto.RegisterType((*HealthCheckResponse)(nil), "broker.rpc.HealthCheckResponse")
	proto.RegisterType((*HealthCheckResponse_EngineStatus)(nil), "broker.rpc.HealthCheckResponse.EngineStatus")
	proto.RegisterType((*GetIdentityResponse)(nil), "broker.rpc.GetIdentityResponse")
	proto.RegisterType((*CreateBlockOrderRequest)(nil), "broker.rpc.CreateBlockOrderRequest")
	proto.RegisterType((*CreateBlockOrderResponse)(nil), "broker.rpc.CreateBlockOrderResponse")
	proto.RegisterType((*Order)(nil), "broker.rpc.Order")
	proto.RegisterType((*Fill)(nil), "broker.rpc.Fill")
	proto.RegisterType((*BlockOrder)(nil), "broker.rpc.BlockOrder")
	proto.RegisterType((*GetBlockOrderRequest)(nil), "broker.rpc.GetBlockOrderRequest")
	proto.RegisterType((*GetBlockOrderResponse)(nil), "broker.rpc.GetBlockOrderResponse")
	proto.RegisterType((*CancelBlockOrderRequest)(nil), "broker.rpc.CancelBlockOrderRequest")
	proto.RegisterType((*GetBlockOrdersResponse)(nil), "broker.rpc.GetBlockOrdersResponse")
	proto.RegisterType((*GetBlockOrdersRequest)(nil), "broker.rpc.GetBlockOrdersRequest")
	proto.RegisterType((*WatchMarketRequest)(nil), "broker.rpc.WatchMarketRequest")
	proto.RegisterType((*WatchMarketResponse)(nil), "broker.rpc.WatchMarketResponse")
	proto.RegisterType((*MarketEvent)(nil), "broker.rpc.MarketEvent")
	proto.RegisterType((*GetOrderbookRequest)(nil), "broker.rpc.GetOrderbookRequest")
	proto.RegisterType((*Bid)(nil), "broker.rpc.Bid")
	proto.RegisterType((*Ask)(nil), "broker.rpc.Ask")
	proto.RegisterType((*GetOrderbookResponse)(nil), "broker.rpc.GetOrderbookResponse")
	proto.RegisterType((*NewDepositAddressRequest)(nil), "broker.rpc.NewDepositAddressRequest")
	proto.RegisterType((*NewDepositAddressResponse)(nil), "broker.rpc.NewDepositAddressResponse")
	proto.RegisterType((*Balance)(nil), "broker.rpc.Balance")
	proto.RegisterType((*GetBalancesResponse)(nil), "broker.rpc.GetBalancesResponse")
	proto.RegisterType((*Capacity)(nil), "broker.rpc.Capacity")
	proto.RegisterType((*GetTradingCapacitiesResponse)(nil), "broker.rpc.GetTradingCapacitiesResponse")
	proto.RegisterType((*GetTradingCapacitiesRequest)(nil), "broker.rpc.GetTradingCapacitiesRequest")
	proto.RegisterType((*CommitRequest)(nil), "broker.rpc.CommitRequest")
	proto.RegisterType((*ReleaseChannelsRequest)(nil), "broker.rpc.ReleaseChannelsRequest")
	proto.RegisterType((*ReleasedCurrency)(nil), "broker.rpc.ReleasedCurrency")
	proto.RegisterType((*ReleaseChannelsResponse)(nil), "broker.rpc.ReleaseChannelsResponse")
	proto.RegisterType((*GetPaymentChannelNetworkAddressRequest)(nil), "broker.rpc.GetPaymentChannelNetworkAddressRequest")
	proto.RegisterType((*GetPaymentChannelNetworkAddressResponse)(nil), "broker.rpc.GetPaymentChannelNetworkAddressResponse")
	proto.RegisterType((*WithdrawFundsRequest)(nil), "broker.rpc.WithdrawFundsRequest")
	proto.RegisterType((*WithdrawFundsResponse)(nil), "broker.rpc.WithdrawFundsResponse")
	proto.RegisterType((*CreateWalletRequest)(nil), "broker.rpc.CreateWalletRequest")
	proto.RegisterType((*CreateWalletResponse)(nil), "broker.rpc.CreateWalletResponse")
	proto.RegisterType((*UnlockWalletRequest)(nil), "broker.rpc.UnlockWalletRequest")
	proto.RegisterType((*SupportedMarket)(nil), "broker.rpc.SupportedMarket")
	proto.RegisterType((*GetSupportedMarketsResponse)(nil), "broker.rpc.GetSupportedMarketsResponse")
	proto.RegisterType((*GetMarketStatsRequest)(nil), "broker.rpc.GetMarketStatsRequest")
	proto.RegisterType((*GetMarketStatsResponse)(nil), "broker.rpc.GetMarketStatsResponse")
	proto.RegisterType((*GetTradesRequest)(nil), "broker.rpc.GetTradesRequest")
	proto.RegisterType((*Trade)(nil), "broker.rpc.Trade")
	proto.RegisterType((*GetTradesResponse)(nil), "broker.rpc.GetTradesResponse")
	proto.RegisterEnum("broker.rpc.Side", Side_name, Side_value)
	proto.RegisterEnum("broker.rpc.TimeInForce", TimeInForce_name, TimeInForce_value)
	proto.RegisterEnum("broker.rpc.Symbol", Symbol_name, Symbol_value)
	proto.RegisterEnum("broker.rpc.Order_OrderStatus", Order_OrderStatus_name, Order_OrderStatus_value)
	proto.RegisterEnum("broker.rpc.Fill_FillStatus", Fill_FillStatus_name, Fill_FillStatus_value)
	proto.RegisterEnum("broker.rpc.BlockOrder_BlockOrderStatus", BlockOrder_BlockOrderStatus_name, BlockOrder_BlockOrderStatus_value)
	proto.RegisterEnum("broker.rpc.WatchMarketResponse_EventType", WatchMarketResponse_EventType_name, WatchMarketResponse_EventType_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for AdminService service

type AdminServiceClient interface {
	// *
	// The HealthCheck returns a status of all of the components of the BrokerDaemon.
	//
	// ```javascript
	// const deadline = new Date().setSeconds(new Date().getSeconds() + 5)
	// adminService.healthCheck({}, { deadline }, (err, { engineStatus, relayerStatus }) => {
	//   if (err) return console.error(err)
	//   console.log({ engineStatus, relayerStatus })
	// })
	// ```
	//
	// ```shell
	// > sparkswap healthcheck
	// ```
	//
	// > The above command will print:
	//
	// ```javascript
	// {
	//   "engineStatus": [
	//     {
	//       "symbol": "BTC",
	//       "status": "OK"
	//     },
	//     {
	//       "symbol": "LTC",
	//       "status": "OK"
	//     },
	//   ],
	//   "relayerStatus": "OK"
	// }
	// ```
	//
	// ```shell
	// Engine status for BTC: OK
	// Engine status for LTC: OK
	// Relayer Status: OK
	// Daemon Status: OK
	// ```
	HealthCheck(ctx context.Context, in *GoogleProtobuf_Empty, opts ...grpc.CallOption) (*HealthCheckResponse, error)
	// *
	// GetIdentity returns the Public Key the BrokerDaemon uses to interact with the Relayer.
	//
	// ```javascript
	// const deadline = new Date().setSeconds(new Date().getSeconds() + 5)
	// adminService.getIdentity({}, { deadline }, (err, { publicKey }) => {
	//   if (err) return console.error(err)
	//   console.log({ publicKey })
	// })
	// ```
	//
	// ```shell
	// > sparkswap id
	// ```
	//
	// > The above command will print:
	//
	// ```javascript
	// {
	//   "publicKey": "-----BEGIN PUBLIC KEY-----\nMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEVbt2b1JHw7Kg2I9340n8jA5ycbyH\neucZq00VNANqsoUSfw2iqRkM4OLVdUZ22YGR+mN/0CgIIwiWxNE6g58V+g==\n-----END PUBLIC KEY-----\n"
	// }
	// ```
	//
	// ```shell
	// -----BEGIN PUBLIC KEY-----
	// MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEVbt2b1JHw7Kg2I9340n8jA5ycbyH
	// eucZq00VNANqsoUSfw2iqRkM4OLVdUZ22YGR+mN/0CgIIwiWxNE6g58V+g==
	// -----END PUBLIC KEY-----
	// ```
	GetIdentity(ctx context.Context, in *GoogleProtobuf_Empty, opts ...grpc.CallOption) (*GetIdentityResponse, error)
}

type adminServiceClient struct {
	cc *grpc.ClientConn
}

func NewAdminServiceClient(cc *grpc.ClientConn) AdminServiceClient {
	return &adminServiceClient{cc}
}

func (c *adminServiceClient) HealthCheck(ctx context.Context, in *GoogleProtobuf_Empty, opts ...grpc.CallOption) (*HealthCheckResponse, error) {
	out := new(HealthCheckResponse)
	err := grpc.Invoke(ctx, "/broker.rpc.AdminService/HealthCheck", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminServiceClient) GetIdentity(ctx context.Context, in *GoogleProtobuf_Empty, opts ...grpc.CallOption) (*GetIdentityResponse, error) {
	out := new(GetIdentityResponse)
	err := grpc.Invoke(ctx, "/broker.rpc.AdminService/GetIdentity", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for AdminService service

type AdminServiceServer interface {
	// *
	// The HealthCheck returns a status of all of the components of the BrokerDaemon.
	//
	// ```javascript
	// const deadline = new Date().setSeconds(new Date().getSeconds() + 5)
	// adminService.healthCheck({}, { deadline }, (err, { engineStatus, relayerStatus }) => {
	//   if (err) return console.error(err)
	//   console.log({ engineStatus, relayerStatus })
	// })
	// ```
	//
	// ```shell
	// > sparkswap healthcheck
	// ```
	//
	// > The above command will print:
	//
	// ```javascript
	// {
	//   "engineStatus": [
	//     {
	//       "symbol": "BTC",
	//       "status": "OK"
	//     },
	//     {
	//       "symbol": "LTC",
	//       "status": "OK"
	//     },
	//   ],
	//   "relayerStatus": "OK"
	// }
	// ```
	//
	// ```shell
	// Engine status for BTC: OK
	// Engine status for LTC: OK
	// Relayer Status: OK
	// Daemon Status: OK
	// ```
	HealthCheck(context.Context, *GoogleProtobuf_Empty) (*HealthCheckResponse, error)
	// *
	// GetIdentity returns the Public Key the BrokerDaemon uses to interact with the Relayer.
	//
	// ```javascript
	// const deadline = new Date().setSeconds(new Date().getSeconds() + 5)
	// adminService.getIdentity({}, { deadline }, (err, { publicKey }) => {
	//   if (err) return console.error(err)
	//   console.log({ publicKey })
	// })
	// ```
	//
	// ```shell
	// > sparkswap id
	// ```
	//
	// > The above command will print:
	//
	// ```javascript
	// {
	//   "publicKey": "-----BEGIN PUBLIC KEY-----\nMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEVbt2b1JHw7Kg2I9340n8jA5ycbyH\neucZq00VNANqsoUSfw2iqRkM4OLVdUZ22YGR+mN/0CgIIwiWxNE6g58V+g==\n-----END PUBLIC KEY-----\n"
	// }
	// ```
	//
	// ```shell
	// -----BEGIN PUBLIC KEY-----
	// MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEVbt2b1JHw7Kg2I9340n8jA5ycbyH
	// eucZq00VNANqsoUSfw2iqRkM4OLVdUZ22YGR+mN/0CgIIwiWxNE6g58V+g==
	// -----END PUBLIC KEY-----
	// ```
	GetIdentity(context.Context, *GoogleProtobuf_Empty) (*GetIdentityResponse, error)
}

func RegisterAdminServiceServer(s *grpc.Server, srv AdminServiceServer) {
	s.RegisterService(&_AdminService_serviceDesc, srv)
}

func _AdminService_HealthCheck_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GoogleProtobuf_Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServiceServer).HealthCheck(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/broker.rpc.AdminService/HealthCheck",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServiceServer).HealthCheck(ctx, req.(*GoogleProtobuf_Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _AdminService_GetIdentity_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GoogleProtobuf_Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServiceServer).GetIdentity(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/broker.rpc.AdminService/GetIdentity",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServiceServer).GetIdentity(ctx, req.(*GoogleProtobuf_Empty))
	}
	return interceptor(ctx, in, info, handler)
}

var _AdminService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "broker.rpc.AdminService",
	HandlerType: (*AdminServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "HealthCheck",
			Handler:    _AdminService_HealthCheck_Handler,
		},
		{
			MethodName: "GetIdentity",
			Handler:    _AdminService_GetIdentity_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "broker.proto",
}

// Client API for OrderService service

type OrderServiceClient interface {
	// *
	// CreateBlockOrder creates new block orders on the Broker. This is the only way to initiate a trade on the broker.
	// Creating a block order returns a block order ID immediately, but that is not necessarily an indication that the block order has been successfully executed.
	// The user should check on the block order's status after it is created to understand if it has been completed.
	//
	// > Placing a market order:
	//
	// ```javascript
	// const deadline = new Date().setSeconds(new Date().getSeconds() + 5)
	// orderService.createBlockOrder(
	//   {
	//     market: 'BTC/LTC', // trading BTC and LTC
	//     side: 'BID', // Place a buy order
	//     amount: '0.0001', // 0.0001 BTC being traded
	//     isMarketOrder: true, // use the best available price
	//     timeInForce: 'GTC' // execute this order until I cancel it
	//   },
	//   { deadline },
	//   (err, { blockOrderId }) => {
	//     if (err) return console.error(err)
	//     console.log({ blockOrderId })
	//   }
	// )
	// ```
	//
	// ```shell
	// > sparkswap buy 0.0001 --market BTC/LTC
	// ```
	//
	// > The above command will create a market block order on the Broker and will print:
	//
	// ```javascript
	// { "blockOrderId": "vQPeeYWTlpTPreJxE3My_mpTBiYwYPnTkd6aU2XX" }
	// ```
	//
	// ```shell
	// { blockOrderId: 'vQPeeYWTlpTPreJxE3My_mpTBiYwYPnTkd6aU2XX' }
	// ```
	//
	// > Placing a limit order:
	//
	// ```javascript
	// const deadline = new Date().setSeconds(new Date().getSeconds() + 5)
	// orderService.createBlockOrder(
	//   {
	//     market: 'BTC/LTC', // trading BTC and LTC
	//     side: 'BID', // Place a buy order
	//     amount: '0.0001', // 0.0001 BTC being traded
	//     limitPrice: '1.1', // at a price no worse than 1.1 LTC per BTC
	//     timeInForce: 'GTC' // execute this order until I cancel it
	//   },
	//   { deadline },
	//   (err, { blockOrderId }) => {
	//     if (err) return console.error(err)
	//     console.log({ blockOrderId })
	//   }
	// )
	// ```
	//
	// ```shell
	// > sparkswap buy 0.0001 1.1 --market BTC/LTC
	// ```
	//
	// > The above command will create a limit block order on the Broker and will print:
	//
	// ```javascript
	// { "blockOrderId": "o2tSlSibkCsw6zi4-mpVuMogeLaz_GZuGqJlhWVs" }
	// ```
	//
	// ```shell
	// { blockOrderId: 'o2tSlSibkCsw6zi4-mpVuMogeLaz_GZuGqJlhWVs' }
	// ```
	//
	CreateBlockOrder(ctx context.Context, in *CreateBlockOrderRequest, opts ...grpc.CallOption) (*CreateBlockOrderResponse, error)
	// *
	// GetBlockOrder returns information on a previously placed block order. It should be used to check on the status of placed block orders.
	//
	// ```javascript
	// const deadline = new Date().setSeconds(new Date().getSeconds() + 5)
	// const blockOrder = orderService.getBlockOrder({ blockOrderId: 'vQPeeYWTlpTPreJxE3My_mpTBiYwYPnTkd6aU2XX' }, { deadline }, (err, blockOrder) => {
	//   if (err) return console.error(err)
	//   console.log(blockOrder)
	// })
	// ```
	//
	// ```shell
	// > sparkswap order status vQPeeYWTlpTPreJxE3My_mpTBiYwYPnTkd6aU2XX
	// ```
	//
	// > The above command will retrieve the block order on the Broker and will print:
	//
	// ```javascript
	// {
	//   "status": "",
	//   "market": "BTC/LTC",
	//   "side": "BID",
	//   "amount": "0.0001",
	//   "isMarketOrder": true,
	//   "timeInForce": "GTC",
	//   "timestamp": "1538676318030164300",
	//   "datetime": "2018-09-21T10:40:31.8342339Z",
	//   "orders": [],
	//   "fills": []
	// }
	// ```
	//
	// ```shell
	// { price_restriction: 'isMarketOrder',
	//   status: 'ACTIVE',
	//   market: 'BTC/LTC',
	//   side: 'BID',
	//   amount: '0.0001000000000000',
	//   isMarketOrder: true,
	//   limitPrice: '',
	//   timeInForce: 'GTC',
	//   timestamp: '1538676318030164300',
	//   datetime: '2018-09-21T10:40:31.8342339Z',
	//   fillAmount: '',
	//   orders: [],
	//   fills: [] }
	// ```
	GetBlockOrder(ctx context.Context, in *GetBlockOrderRequest, opts ...grpc.CallOption) (*GetBlockOrderResponse, error)
	// *
	// CancelBlockOrder cancels a previously placed block order.
	// If the block order is already completed, or consists only of orders that are already being filled (either by this Broker or a counterparty), this will have no effect, as the Broker is bound to complete those orders or else lose their deposit.
	// If the block order is partially executed, the cancel will affect only future actions, the Broker will not attempt to roll back trades that have already been made.
	//
	// ```javascript
	// const deadline = new Date().setSeconds(new Date().getSeconds() + 5)
	// orderService.getBlockOrder({ blockOrderId: 'vQPeeYWTlpTPreJxE3My_mpTBiYwYPnTkd6aU2XX' }, { deadline }, (err) => {
	//   if (err) return console.error(err)
	// })
	// ```
	//
	// ```shell
	// > sparkswap order cancel vQPeeYWTlpTPreJxE3My_mpTBiYwYPnTkd6aU2XX
	// ```
	//
	// > The above command will cancel the block order, but has no output.
	CancelBlockOrder(ctx context.Context, in *CancelBlockOrderRequest, opts ...grpc.CallOption) (*GoogleProtobuf_Empty, error)
	// *
	// GetBlockOrders returns information on all of the block orders placed in a single market, like `BTC/LTC`.
	// It does not include complete information, such as the underlying orders and fills on the SparkSwap Relayer, or the amount of the order that has been filled. For that, use [GetBlockOrder](#getblockorder).
	//
	// ```javascript
	// const deadline = new Date().setSeconds(new Date().getSeconds() + 5)
	// orderService.getBlockOrders({ market: 'BTC/LTC' }, { deadline }, (err, { blockOrders }) => {
	//   if (err) return console.error(err)
	//   console.log(blockOrders)
	// })
	// ```
	//
	// ```shell
	// > sparkswap order summary --market BTC/LTC
	// ```
	//
	// > The above command will retrieve the block orders on the Broker and will print:
	//
	// ```javascript
	// [
	//   {
	//     "status": "",
	//     "market": "BTC/LTC",
	//     "side": "BID",
	//     "amount": "0.0001",
	//     "isMarketOrder": true,
	//     "timeInForce": "GTC"
	//   },
	//   {
	//     "status": "",
	//     "market": "BTC/LTC",
	//     "side": "BID",
	//     "amount": "0.0001",
	//     "limitPrice": "1.1",
	//     "timeInForce": "GTC"
	//   }
	// ]
	// ```
	//
	// ```shell
	// ┌─────────────────────────────────────────────┬───────┬──────────────────┬──────────────────┬──────┬──────────┐
	// │ Order ID                                    │ Side  │ Amount           │ Limit Price      │ Time │ Status   │
	// ├─────────────────────────────────────────────┼───────┼──────────────────┼──────────────────┼──────┼──────────┤
	// │ o2tSlSibkCsw6zi4-mpVuMogeLaz_GZuGqJlhWVs    │ BID   │ 0.0001000000000… │ 1.1000000000000… │ GTC  │ ACTIVE   │
	// ├─────────────────────────────────────────────┼───────┼──────────────────┼──────────────────┼──────┼──────────┤
	// │ vQPeeYWTlpTPreJxE3My_mpTBiYwYPnTkd6aU2XX    │ BID   │ 0.0001000000000… │ MARKET           │ GTC  │ ACTIVE   │
	// └─────────────────────────────────────────────┴───────┴──────────────────┴──────────────────┴──────┴──────────┘
	// ```
	GetBlockOrders(ctx context.Context, in *GetBlockOrdersRequest, opts ...grpc.CallOption) (*GetBlockOrdersResponse, error)
}

type orderServiceClient struct {
	cc *grpc.ClientConn
}

func NewOrderServiceClient(cc *grpc.ClientConn) OrderServiceClient {
	return &orderServiceClient{cc}
}

func (c *orderServiceClient) CreateBlockOrder(ctx context.Context, in *CreateBlockOrderRequest, opts ...grpc.CallOption) (*CreateBlockOrderResponse, error) {
	out := new(CreateBlockOrderResponse)
	err := grpc.Invoke(ctx, "/broker.rpc.OrderService/CreateBlockOrder", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *orderServiceClient) GetBlockOrder(ctx context.Context, in *GetBlockOrderRequest, opts ...grpc.CallOption) (*GetBlockOrderResponse, error) {
	out := new(GetBlockOrderResponse)
	err := grpc.Invoke(ctx, "/broker.rpc.OrderService/GetBlockOrder", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *orderServiceClient) CancelBlockOrder(ctx context.Context, in *CancelBlockOrderRequest, opts ...grpc.CallOption) (*GoogleProtobuf_Empty, error) {
	out := new(GoogleProtobuf_Empty)
	err := grpc.Invoke(ctx, "/broker.rpc.OrderService/CancelBlockOrder", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *orderServiceClient) GetBlockOrders(ctx context.Context, in *GetBlockOrdersRequest, opts ...grpc.CallOption) (*GetBlockOrdersResponse, error) {
	out := new(GetBlockOrdersResponse)
	err := grpc.Invoke(ctx, "/broker.rpc.OrderService/GetBlockOrders", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for OrderService service

type OrderServiceServer interface {
	// *
	// CreateBlockOrder creates new block orders on the Broker. This is the only way to initiate a trade on the broker.
	// Creating a block order returns a block order ID immediately, but that is not necessarily an indication that the block order has been successfully executed.
	// The user should check on the block order's status after it is created to understand if it has been completed.
	//
	// > Placing a market order:
	//
	// ```javascript
	// const deadline = new Date().setSeconds(new Date().getSeconds() + 5)
	// orderService.createBlockOrder(
	//   {
	//     market: 'BTC/LTC', // trading BTC and LTC
	//     side: 'BID', // Place a buy order
	//     amount: '0.0001', // 0.0001 BTC being traded
	//     isMarketOrder: true, // use the best available price
	//     timeInForce: 'GTC' // execute this order until I cancel it
	//   },
	//   { deadline },
	//   (err, { blockOrderId }) => {
	//     if (err) return console.error(err)
	//     console.log({ blockOrderId })
	//   }
	// )
	// ```
	//
	// ```shell
	// > sparkswap buy 0.0001 --market BTC/LTC
	// ```
	//
	// > The above command will create a market block order on the Broker and will print:
	//
	// ```javascript
	// { "blockOrderId": "vQPeeYWTlpTPreJxE3My_mpTBiYwYPnTkd6aU2XX" }
	// ```
	//
	// ```shell
	// { blockOrderId: 'vQPeeYWTlpTPreJxE3My_mpTBiYwYPnTkd6aU2XX' }
	// ```
	//
	// > Placing a limit order:
	//
	// ```javascript
	// const deadline = new Date().setSeconds(new Date().getSeconds() + 5)
	// orderService.createBlockOrder(
	//   {
	//     market: 'BTC/LTC', // trading BTC and LTC
	//     side: 'BID', // Place a buy order
	//     amount: '0.0001', // 0.0001 BTC being traded
	//     limitPrice: '1.1', // at a price no worse than 1.1 LTC per BTC
	//     timeInForce: 'GTC' // execute this order until I cancel it
	//   },
	//   { deadline },
	//   (err, { blockOrderId }) => {
	//     if (err) return console.error(err)
	//     console.log({ blockOrderId })
	//   }
	// )
	// ```
	//
	// ```shell
	// > sparkswap buy 0.0001 1.1 --market BTC/LTC
	// ```
	//
	// > The above command will create a limit block order on the Broker and will print:
	//
	// ```javascript
	// { "blockOrderId": "o2tSlSibkCsw6zi4-mpVuMogeLaz_GZuGqJlhWVs" }
	// ```
	//
	// ```shell
	// { blockOrderId: 'o2tSlSibkCsw6zi4-mpVuMogeLaz_GZuGqJlhWVs' }
	// ```
	//
	CreateBlockOrder(context.Context, *CreateBlockOrderRequest) (*CreateBlockOrderResponse, error)
	// *
	// GetBlockOrder returns information on a previously placed block order. It should be used to check on the status of placed block orders.
	//
	// ```javascript
	// const deadline = new Date().setSeconds(new Date().getSeconds() + 5)
	// const blockOrder = orderService.getBlockOrder({ blockOrderId: 'vQPeeYWTlpTPreJxE3My_mpTBiYwYPnTkd6aU2XX' }, { deadline }, (err, blockOrder) => {
	//   if (err) return console.error(err)
	//   console.log(blockOrder)
	// })
	// ```
	//
	// ```shell
	// > sparkswap order status vQPeeYWTlpTPreJxE3My_mpTBiYwYPnTkd6aU2XX
	// ```
	//
	// > The above command will retrieve the block order on the Broker and will print:
	//
	// ```javascript
	// {
	//   "status": "",
	//   "market": "BTC/LTC",
	//   "side": "BID",
	//   "amount": "0.0001",
	//   "isMarketOrder": true,
	//   "timeInForce": "GTC",
	//   "timestamp": "1538676318030164300",
	//   "datetime": "2018-09-21T10:40:31.8342339Z",
	//   "orders": [],
	//   "fills": []
	// }
	// ```
	//
	// ```shell
	// { price_restriction: 'isMarketOrder',
	//   status: 'ACTIVE',
	//   market: 'BTC/LTC',
	//   side: 'BID',
	//   amount: '0.0001000000000000',
	//   isMarketOrder: true,
	//   limitPrice: '',
	//   timeInForce: 'GTC',
	//   timestamp: '1538676318030164300',
	//   datetime: '2018-09-21T10:40:31.8342339Z',
	//   fillAmount: '',
	//   orders: [],
	//   fills: [] }
	// ```
	GetBlockOrder(context.Context, *GetBlockOrderRequest) (*GetBlockOrderResponse, error)
	// *
	// CancelBlockOrder cancels a previously placed block order.
	// If the block order is already completed, or consists only of orders that are already being filled (either by this Broker or a counterparty), this will have no effect, as the Broker is bound to complete those orders or else lose their deposit.
	// If the block order is partially executed, the cancel will affect only future actions, the Broker will not attempt to roll back trades that have already been made.
	//
	// ```javascript
	// const deadline = new Date().setSeconds(new Date().getSeconds() + 5)
	// orderService.getBlockOrder({ blockOrderId: 'vQPeeYWTlpTPreJxE3My_mpTBiYwYPnTkd6aU2XX' }, { deadline }, (err) => {
	//   if (err) return console.error(err)
	// })
	// ```
	//
	// ```shell
	// > sparkswap order cancel vQPeeYWTlpTPreJxE3My_mpTBiYwYPnTkd6aU2XX
	// ```
	//
	// > The above command will cancel the block order, but has no output.
	CancelBlockOrder(context.Context, *CancelBlockOrderRequest) (*GoogleProtobuf_Empty, error)
	// *
	// GetBlockOrders returns information on all of the block orders placed in a single market, like `BTC/LTC`.
	// It does not include complete information, such as the underlying orders and fills on the SparkSwap Relayer, or the amount of the order that has been filled. For that, use [GetBlockOrder](#getblockorder).
	//
	// ```javascript
	// const deadline = new Date().setSeconds(new Date().getSeconds() + 5)
	// orderService.getBlockOrders({ market: 'BTC/LTC' }, { deadline }, (err, { blockOrders }) => {
	//   if (err) return console.error(err)
	//   console.log(blockOrders)
	// })
	// ```
	//
	// ```shell
	// > sparkswap order summary --market BTC/LTC
	// ```
	//
	// > The above command will retrieve the block orders on the Broker and will print:
	//
	// ```javascript
	// [
	//   {
	//     "status": "",
	//     "market": "BTC/LTC",
	//     "side": "BID",
	//     "amount": "0.0001",
	//     "isMarketOrder": true,
	//     "timeInForce": "GTC"
	//   },
	//   {
	//     "status": "",
	//     "market": "BTC/LTC",
	//     "side": "BID",
	//     "amount": "0.0001",
	//     "limitPrice": "1.1",
	//     "timeInForce": "GTC"
	//   }
	// ]
	// ```
	//
	// ```shell
	// ┌─────────────────────────────────────────────┬───────┬──────────────────┬──────────────────┬──────┬──────────┐
	// │ Order ID                                    │ Side  │ Amount           │ Limit Price      │ Time │ Status   │
	// ├─────────────────────────────────────────────┼───────┼──────────────────┼──────────────────┼──────┼──────────┤
	// │ o2tSlSibkCsw6zi4-mpVuMogeLaz_GZuGqJlhWVs    │ BID   │ 0.0001000000000… │ 1.1000000000000… │ GTC  │ ACTIVE   │
	// ├─────────────────────────────────────────────┼───────┼──────────────────┼──────────────────┼──────┼──────────┤
	// │ vQPeeYWTlpTPreJxE3My_mpTBiYwYPnTkd6aU2XX    │ BID   │ 0.0001000000000… │ MARKET           │ GTC  │ ACTIVE   │
	// └─────────────────────────────────────────────┴───────┴──────────────────┴──────────────────┴──────┴──────────┘
	// ```
	GetBlockOrders(context.Context, *GetBlockOrdersRequest) (*GetBlockOrdersResponse, error)
}

func RegisterOrderServiceServer(s *grpc.Server, srv OrderServiceServer) {
	s.RegisterService(&_OrderService_serviceDesc, srv)
}

func _OrderService_CreateBlockOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateBlockOrderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrderServiceServer).CreateBlockOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/broker.rpc.OrderService/CreateBlockOrder",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrderServiceServer).CreateBlockOrder(ctx, req.(*CreateBlockOrderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OrderService_GetBlockOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBlockOrderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrderServiceServer).GetBlockOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/broker.rpc.OrderService/GetBlockOrder",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrderServiceServer).GetBlockOrder(ctx, req.(*GetBlockOrderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OrderService_CancelBlockOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CancelBlockOrderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrderServiceServer).CancelBlockOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/broker.rpc.OrderService/CancelBlockOrder",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrderServiceServer).CancelBlockOrder(ctx, req.(*CancelBlockOrderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OrderService_GetBlockOrders_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBlockOrdersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrderServiceServer).GetBlockOrders(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/broker.rpc.OrderService/GetBlockOrders",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrderServiceServer).GetBlockOrders(ctx, req.(*GetBlockOrdersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _OrderService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "broker.rpc.OrderService",
	HandlerType: (*OrderServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateBlockOrder",
			Handler:    _OrderService_CreateBlockOrder_Handler,
		},
		{
			MethodName: "GetBlockOrder",
			Handler:    _OrderService_GetBlockOrder_Handler,
		},
		{
			MethodName: "CancelBlockOrder",
			Handler:    _OrderService_CancelBlockOrder_Handler,
		},
		{
			MethodName: "GetBlockOrders",
			Handler:    _OrderService_GetBlockOrders_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "broker.proto",
}

// Client API for OrderBookService service

type OrderBookServiceClient interface {
	// *
	// WatchMarket opens a stream from the Broker with updates as to the current state of the orderbook.
	// Those updates come in the form of `ADD`s and `DELETE`s, so by updating a UI with those changes, the user can see the current state of the orderbook.
	// > Below is a simple example of a console-based UI for an orderbook:
	//
	// ```javascript
	// const call = orderBookService.watchMarket(request)
	// const orders = new Map()
	// call.on('data', (update) => {
	//   const { orderId, side, price, amount } = update.marketEvent
	//   const { type } = update
	//   if (type === EVENT_TYPES.DELETE) {
	//     orders.delete(orderId)
	//   } else {
	//     orders.set(orderId, { price, amount })
	//   }
	//   console.clear()
	//   console.log(Array.from(orders.values()).sort(function (a, b) { return parseFloat(a) - parseFloat(b) }))
	// })
	// ```
	//
	// ```shell
	// > sparkswap orderbook --market BTC/LTC
	// ```
	//
	// > After an update, the UI would show something like this:
	//
	// ```javascript
	// [
	//   {
	//     "side": "ASK",
	//     "price": "1.1",
	//     "amount": "0.0001"
	//   },
	//   {
	//     "side": "ASK",
	//     "price": "1.0",
	//     "amount": "0.0001"
	//   }
	// ]
	// ```
	//
	// ```shell
	// Market: BTC/LTC                                                                                                                            Ϟ SparkSwap Broker
	//                                                                                                                                           v0.2.0-alpha-preview
	//                                                                                                                                           http://sparkswap.com
	//
	// ┌──────────────────────────────────────────────────────────────────────────────┬──────────────────────────────────────────────────────────────────────────────┐
	// │ ASKS                                                                         │ BIDS                                                                         │
	// ├──────────────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────────────┤
	// │  Price                                Depth (BTC)                            │  Price                                Depth (BTC)                            │
	// │                                                                              │   1.2970000000000000                   0.0001000000000000                    │
	// │                                                                              │   1.2970000000000000                   0.0001000000000000                    │
	// │                                                                              │   1.1930000000000000                   0.0001000000000000                    │
	// │                                                                              │   1.1790000000000000                   0.0001300000000000                    │
	// │                                                                              │   1.1680000000000000                   0.0002000000000000                    │
	// │                                                                              │   1.1000000000000000                   0.0002000000000000                    │
	// └──────────────────────────────────────────────────────────────────────────────┴──────────────────────────────────────────────────────────────────────────────┘
	//
	// ```
	WatchMarket(ctx context.Context, in *WatchMarketRequest, opts ...grpc.CallOption) (OrderBookService_WatchMarketClient, error)
	// *
	// GetOrderbook returns price and amount information about the bids and asks on the orderbook in the current state.
	// > Below is a simple example of a console-based UI for an orderbook:
	//
	// ```javascript
	// const { bids, asks, timestamp, datetime } = orderBookService.getOrderbook(request)
	// console.log({ bids, asks, timestamp, datetime })
	// ```
	//
	//
	// > The response from the above call would look like:
	//
	// ```javascript
	// { bids:
	//    [ { price: '0.0003000000000000', amount: '0.0000100000000000' },
	//      { price: '0.0002000000000000', amount: '0.0000100000000000' } ],
	//   asks:
	//    [ { price: '0.0003000000000000', amount: '0.0000300000000000' } ],
	//   timestamp: '1537466254497',
	//   datetime: '2018-09-20T16:27:28.0733219Z' }
	// ```
	GetOrderbook(ctx context.Context, in *GetOrderbookRequest, opts ...grpc.CallOption) (*GetOrderbookResponse, error)
}

type orderBookServiceClient struct {
	cc *grpc.ClientConn
}

func NewOrderBookServiceClient(cc *grpc.ClientConn) OrderBookServiceClient {
	return &orderBookServiceClient{cc}
}

func (c *orderBookServiceClient) WatchMarket(ctx context.Context, in *WatchMarketRequest, opts ...grpc.CallOption) (OrderBookService_WatchMarketClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_OrderBookService_serviceDesc.Streams[0], c.cc, "/broker.rpc.OrderBookService/WatchMarket", opts...)
	if err != nil {
		return nil, err
	}
	x := &orderBookServiceWatchMarketClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type OrderBookService_WatchMarketClient interface {
	Recv() (*WatchMarketResponse, error)
	grpc.ClientStream
}

type orderBookServiceWatchMarketClient struct {
	grpc.ClientStream
}

func (x *orderBookServiceWatchMarketClient) Recv() (*WatchMarketResponse, error) {
	m := new(WatchMarketResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *orderBookServiceClient) GetOrderbook(ctx context.Context, in *GetOrderbookRequest, opts ...grpc.CallOption) (*GetOrderbookResponse, error) {
	out := new(GetOrderbookResponse)
	err := grpc.Invoke(ctx, "/broker.rpc.OrderBookService/GetOrderbook", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for OrderBookService service

type OrderBookServiceServer interface {
	// *
	// WatchMarket opens a stream from the Broker with updates as to the current state of the orderbook.
	// Those updates come in the form of `ADD`s and `DELETE`s, so by updating a UI with those changes, the user can see the current state of the orderbook.
	// > Below is a simple example of a console-based UI for an orderbook:
	//
	// ```javascript
	// const call = orderBookService.watchMarket(request)
	// const orders = new Map()
	// call.on('data', (update) => {
	//   const { orderId, side, price, amount } = update.marketEvent
	//   const { type } = update
	//   if (type === EVENT_TYPES.DELETE) {
	//     orders.delete(orderId)
	//   } else {
	//     orders.set(orderId, { price, amount })
	//   }
	//   console.clear()
	//   console.log(Array.from(orders.values()).sort(function (a, b) { return parseFloat(a) - parseFloat(b) }))
	// })
	// ```
	//
	// ```shell
	// > sparkswap orderbook --market BTC/LTC
	// ```
	//
	// > After an update, the UI would show something like this:
	//
	// ```javascript
	// [
	//   {
	//     "side": "ASK",
	//     "price": "1.1",
	//     "amount": "0.0001"
	//   },
	//   {
	//     "side": "ASK",
	//     "price": "1.0",
	//     "amount": "0.0001"
	//   }
	// ]
	// ```
	//
	// ```shell
	// Market: BTC/LTC                                                                                                                            Ϟ SparkSwap Broker
	//                                                                                                                                           v0.2.0-alpha-preview
	//                                                                                                                                           http://sparkswap.com
	//
	// ┌──────────────────────────────────────────────────────────────────────────────┬──────────────────────────────────────────────────────────────────────────────┐
	// │ ASKS                                                                         │ BIDS                                                                         │
	// ├──────────────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────────────┤
	// │  Price                                Depth (BTC)                            │  Price                                Depth (BTC)                            │
	// │                                                                              │   1.2970000000000000                   0.0001000000000000                    │
	// │                                                                              │   1.2970000000000000                   0.0001000000000000                    │
	// │                                                                              │   1.1930000000000000                   0.0001000000000000                    │
	// │                                                                              │   1.1790000000000000                   0.0001300000000000                    │
	// │                                                                              │   1.1680000000000000                   0.0002000000000000                    │
	// │                                                                              │   1.1000000000000000                   0.0002000000000000                    │
	// └──────────────────────────────────────────────────────────────────────────────┴──────────────────────────────────────────────────────────────────────────────┘
	//
	// ```
	WatchMarket(*WatchMarketRequest, OrderBookService_WatchMarketServer) error
	// *
	// GetOrderbook returns price and amount information about the bids and asks on the orderbook in the current state.
	// > Below is a simple example of a console-based UI for an orderbook:
	//
	// ```javascript
	// const { bids, asks, timestamp, datetime } = orderBookService.getOrderbook(request)
	// console.log({ bids, asks, timestamp, datetime })
	// ```
	//
	//
	// > The response from the above call would look like:
	//
	// ```javascript
	// { bids:
	//    [ { price: '0.0003000000000000', amount: '0.0000100000000000' },
	//      { price: '0.0002000000000000', amount: '0.0000100000000000' } ],
	//   asks:
	//    [ { price: '0.0003000000000000', amount: '0.0000300000000000' } ],
	//   timestamp: '1537466254497',
	//   datetime: '2018-09-20T16:27:28.0733219Z' }
	// ```
	GetOrderbook(context.Context, *GetOrderbookRequest) (*GetOrderbookResponse, error)
}

func RegisterOrderBookServiceServer(s *grpc.Server, srv OrderBookServiceServer) {
	s.RegisterService(&_OrderBookService_serviceDesc, srv)
}

func _OrderBookService_WatchMarket_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(WatchMarketRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(OrderBookServiceServer).WatchMarket(m, &orderBookServiceWatchMarketServer{stream})
}

type OrderBookService_WatchMarketServer interface {
	Send(*WatchMarketResponse) error
	grpc.ServerStream
}

type orderBookServiceWatchMarketServer struct {
	grpc.ServerStream
}

func (x *orderBookServiceWatchMarketServer) Send(m *WatchMarketResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _OrderBookService_GetOrderbook_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetOrderbookRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrderBookServiceServer).GetOrderbook(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/broker.rpc.OrderBookService/GetOrderbook",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrderBookServiceServer).GetOrderbook(ctx, req.(*GetOrderbookRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _OrderBookService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "broker.rpc.OrderBookService",
	HandlerType: (*OrderBookServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetOrderbook",
			Handler:    _OrderBookService_GetOrderbook_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "WatchMarket",
			Handler:       _OrderBookService_WatchMarket_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "broker.proto",
}

// Client API for WalletService service

type WalletServiceClient interface {
	// *
	// NewDepositAddress generates a new address for the user to deposit currency into to be used for trading.
	// The address is managed by a wallet in an underlying Payment Channel Network node, and so should be considered a hot wallet.
	//
	// ```javascript
	// const address = await walletService.newDepositAddress({ symbol: 'BTC' })
	// console.log(address)
	// ```
	//
	// ```shell
	// > sparkswap wallet new-deposit-address BTC
	// ```
	//
	// > The above command will print:
	//
	// ```javascript
	// > TODO
	// ```
	//
	// ```shell
	// sb1qsakedujs4exdq5dz2cpldcph6hlvf82l8mn8uk
	// ```
	NewDepositAddress(ctx context.Context, in *NewDepositAddressRequest, opts ...grpc.CallOption) (*NewDepositAddressResponse, error)
	// *
	// GetBalances retrieves the balance in all currency in wallets managed by Payment Channel Network nodes for this Broker.
	//
	// Balances are divided into `uncommittedBalance`, i.e. everything not in a channel, `totalChannelBalance` (i.e. everything in channels opened by the Payment Channel Network nodes),
	// `totalPendingChannelBalance`, i.e. funds in channels that have finished the funding workflow and are waiting for confirmations for the funding txn, and
	// `uncommittedPendingBalance`, i.e funds in channels that are pending closure or unconfirmed unspent outputs under control of the wallet.
	//
	// NOTE: If an engine is unavailable, the balances for the particular engine will be empty `''`
	//
	// ```javascript
	// const deadline = new Date().setSeconds(new Date().getSeconds() + 5)
	// walletService.getBalances({}, { deadline }, (err, { balances }) => {
	//   if (err) return console.error(err)
	//   console.log(balances)
	// })
	// ```
	//
	// ```shell
	// > sparkswap wallet balance
	// ```
	//
	// > The above command will print:
	//
	// ```javascript
	// [
	//   {
	//     "symbol": "BTC",
	//     "uncommittedBalance": "10.0000000000000000",
	//     "totalChannelBalance": "0.1670000000000000",
	//     "totalPendingChannelBalance": "0.0001000000000000",
	//     "uncommittedPendingBalance": "0"
	//   },
	//   {
	//     "symbol": "LTC",
	//     "uncommittedBalance": "10.0000000000000000",
	//     "totalChannelBalance": "0.1670000000000000",
	//     "totalPendingChannelBalance": "0.0002000000000000",
	//     "uncommittedPendingBalance": "0"
	//   }
	// ]
	// ```
	//
	// ```shell
	// Wallet Balances
	// ┌──────────┬──────────────────────────────────┬──────────────────────────────────┐
	// │          │ Committed (Pending)              │ Uncommitted (Pending)            │
	// ├──────────┼──────────────────────────────────┼──────────────────────────────────┤
	// │ BTC      │ 0.1676816500000000 (0.00000000)  │ 9.8321513500000000 (0.00000000)  │
	// ├──────────┼──────────────────────────────────┼──────────────────────────────────┤
	// │ LTC      │ 0.0000000000000000 (0.00000000)  │ 10.0000000000000000 (0.00000000) │
	// └──────────┴──────────────────────────────────┴──────────────────────────────────┘
	// ```
	GetBalances(ctx context.Context, in *GoogleProtobuf_Empty, opts ...grpc.CallOption) (*GetBalancesResponse, error)
	// *
	// Commit opens a channel with the Relayer with the given amount of currency on the Broker's side, and requests that the Relayer open a channel to the Broker with the inverse currency of equivalent amount on the Relayer's side.
	// This allows the Broker to trade in the market, since it has an outgoing channel and an incoming channel.
	//
	// The market parameter will determine the inverse currency, if you commit LTC to the BTC/LTC market, the Broker will request a BTC channel to be opened from the Relayer.
	//
	// Since the Network is in testing stages, rather than relying on the Network's exchange rate between BTC and LTC to determine how large of a channel to open, we use a set rate of 60 LTC to 1 BTC.
	// This also has the property of matching the conversion used in LND, so that when we run into things like the max channel size (in place while LND is in Beta), we can be consistent with LTC and BTC.
	//
	// > The below command has no output, but will throw an error if one is encountered.
	//
	// ```javascript
	// const deadline = new Date().setSeconds(new Date().getSeconds() + 5)
	// walletService.commit(
	//   {
	//     // We are committing LTC to a channel on the BTC/LTC market
	//     // the Broker will request a BTC channel be opened back to itself.
	//     symbol: 'LTC',
	//     // The amount to commit to the channel in common units (e.g. 0.016 BTC).
	//     // The Broker will request a BTC channel of size 0.0167 / 60 be opened back to itself.
	//     balance: '0.0167',
	//     market: 'BTC/LTC'
	//   },
	//   { deadline },
	//   (err) => {
	//     if (err) return console.error(err)
	//   }
	// )
	// ```
	//
	// ```shell
	// > sparkswap wallet commit LTC --market BTC/LTC
	// ```
	Commit(ctx context.Context, in *CommitRequest, opts ...grpc.CallOption) (*GoogleProtobuf_Empty, error)
	// *
	// ReleaseChannels closes all the channels on the given market.
	// If you pass in `BTC/LTC` as the market to releaseChannels, closeChannels will be called on both the BTC and LTC engines. If channels were closed,
	// there will an empty response unless an error is encountered.
	//
	// > The below command has no output, but will throw an error if one is encountered.
	//
	// ```javascript
	// walletService.releaseChannels( { market: 'BTC/LTC' }, (err) => {
	//   if (err) return console.error(err)
	// })
	// ```
	//
	// ```shell
	// > sparkswap wallet release --market BTC/LTC
	// ```
	//
	// > Additionally, you can pass a `force` flag which will force close channels on a specific market
	//
	// ```javascript
	// walletService.releaseChannels( { market: 'BTC/LTC', force: true }, (err) => {
	//   if (err) return console.error(err)
	// })
	// ```
	//
	// ```shell
	// > sparkswap wallet release --market BTC/LTC --force
	// ```
	//
	ReleaseChannels(ctx context.Context, in *ReleaseChannelsRequest, opts ...grpc.CallOption) (*ReleaseChannelsResponse, error)
	// *
	// GetPaymentChannelNetworkAddress retrieves the Payment Channel Network Address for the given currency.
	//
	// ```javascript
	// const { paymentChannelNetworkAddress } = await walletService.getPaymentChannelNetworkAddress({ symbol: 'BTC' })
	// console.log(paymentChannelNetworkAddress)
	// ```
	//
	// ```shell
	// > sparkswap wallet network-address BTC
	// ```
	//
	// > The above command will print:
	//
	// ```javascript
	// > "025f08036e00e38468f52d68bb83939995440b72730bfaae99ace5630630997623@your.daemon:10113"
	// ```
	//
	// ```shell
	// 025f08036e00e38468f52d68bb83939995440b72730bfaae99ace5630630997623@your.daemon:10113
	// ```
	GetPaymentChannelNetworkAddress(ctx context.Context, in *GetPaymentChannelNetworkAddressRequest, opts ...grpc.CallOption) (*GetPaymentChannelNetworkAddressResponse, error)
	// *
	// GetTradingCapacities retrieves the remote and local capacities from the base and counter engines active, pending and inactive channels.
	//
	// Capacities are divided into three categories, active, pending and inactive. Each of these categories are further broken down into
	// the categories local and remote. For example, the activeSendCapacity is the local capacity in active channels for that engine, where pendingReceiveCapacity
	// is the remote capacity in pending channels for that engine. The response from GetTradingCapacities is a baseSymbolCapacities and counterSymbolCapacities
	// object where the respective capacities are grouped.
	//
	// ```javascript
	// walletService.getTradingCapacities({market: 'BTC/LTC}, (err, { baseSymbolCapacities, counterSymbolCapacities }) => {
	//   if (err) return console.error(err)
	//   console.log(baseSymbolCapacities)
	//   console.log(counterSymbolCapacities)
	// })
	// ```
	//
	// ```shell
	// > sparkswap wallet network-status --market BTC/LTC
	// ```
	//
	// > The above command will print:
	//
	// ```javascript
	// { "symbol": "BTC",
	//   "activeSendCapacity": "0.16768165",
	//   "activeReceiveCapacity": "0.0027057",
	//   "pendingSendCapacity": "0",
	//   "pendingReceiveCapacity": "0",
	//   "inactiveSendCapacity": "0",
	//   "inactiveReceiveCapacity": "0"
	// },
	// { "symbol": "LTC",
	//   "activeSendCapacity": "0.16741015",
	//   "activeReceiveCapacity": "10.065967",
	//   "pendingSendCapacity": "0",
	//   "pendingReceiveCapacity": "0",
	//   "inactiveSendCapacity": "0",
	//   "inactiveReceiveCapacity": "0"
	// }
	// ```
	//
	// ```shell
	// BTC/LTC
	// ┌──────────────┬────────────────────────┬────────────────────────┐
	// │              │ BTC Capacity           │ LTC Capacity           │
	// ├──────────────┼────────────────────────┼────────────────────────┤
	// │ Available    │                        │                        │
	// ├──────────────┼────────────────────────┼────────────────────────┤
	// │   Buy BTC    │ 0.0000380000000000     │ 0.0000000000000000     │
	// ├──────────────┼────────────────────────┼────────────────────────┤
	// │   Sell BTC   │ 0.1436436500000000     │ 10.0599490000000000    │
	// ├──────────────┼────────────────────────┼────────────────────────┤
	// │ Outstanding  │                        │                        │
	// ├──────────────┼────────────────────────┼────────────────────────┤
	// │   Buy BTC    │ 0.0027057000000000     │ 0.1674101500000000     │
	// ├──────────────┼────────────────────────┼────────────────────────┤
	// │   Sell BTC   │ 0.1676816500000000     │ 10.0659670000000000    │
	// ├──────────────┼────────────────────────┼────────────────────────┤
	// │ Pending      │                        │                        │
	// ├──────────────┼────────────────────────┼────────────────────────┤
	// │   Buy BTC    │ 0.0000000000000000     │ 0.0000000000000000     │
	// ├──────────────┼────────────────────────┼────────────────────────┤
	// │   Sell BTC   │ 0.0000000000000000     │ 0.0000000000000000     │
	// ├──────────────┼────────────────────────┼────────────────────────┤
	// │ Inactive     │                        │                        │
	// ├──────────────┼────────────────────────┼────────────────────────┤
	// │   Buy BTC    │ 0.0000000000000000     │ 0.0000000000000000     │
	// ├──────────────┼────────────────────────┼────────────────────────┤
	// │   Sell BTC   │ 0.0000000000000000     │ 0.0000000000000000     │
	// └──────────────┴────────────────────────┴────────────────────────┘
	// ```
	GetTradingCapacities(ctx context.Context, in *GetTradingCapacitiesRequest, opts ...grpc.CallOption) (*GetTradingCapacitiesResponse, error)
	// *
	// WithdrawFunds moves funds (of the specified currency and amount) to the specified address
	//
	// ```javascript
	// const { txid } = await walletService.withdrawFunds({ symbol: 'BTC', amount: '2', address: 'asdfasdf' })
	// console.log(txid)
	// ```
	//
	// ```shell
	// > sparkswap wallet withdraw BTC 10 --wallet-address asdfadf
	// ```
	//
	// > The above command will print:
	//
	// ```javascript
	// '66a581f618ee68dde53142c55e924d56cd2b2c169be5b374bc810ac692fb17fd'
	// ```
	//
	// ```shell
	// Successfully withdrew 2 BTC from your wallet! { id: '66a581f618ee68dde53142c55e924d56cd2b2c169be5b374bc810ac692fb17fd' }
	// ```
	WithdrawFunds(ctx context.Context, in *WithdrawFundsRequest, opts ...grpc.CallOption) (*WithdrawFundsResponse, error)
	// *
	// CreateWallet creates a wallet within an engine. This RPC is used as during a 'first-use'
	// setup.
	//
	// When a broker daemon is first getting setup, no crypto-wallets will exist on any of
	// the provided engines. It is the user's responsiblity to create a wallet for each currency
	// and to save the backup information (password and cipher seeds) that are used and returned
	// from this method.
	//
	// ```javascript
	// const { recoverySeed } = await walletService.withdrawFunds({ symbol: 'BTC', password: 'your-secure-password')
	// console.log(recoverySeed)
	// ```
	//
	// ```shell
	// > sparkswap wallet create BTC
	// ```
	//
	// > The above command will print:
	//
	// ```javascript
	// [ 'your',
	//   'cipher'
	//    ... ]
	// ```
	//
	// ```shell
	// > Please enter a password:
	// > Please confirm password:
	// IMPORTANT: Please make a copy of the recovery seed below as you WILL NOT
	// be able to recover this information again. We recommend that you write
	// down all the secret words, and re-confirm the order they are written down
	//
	// [ 'your',
	//   'cipher'
	//    ... ]
	// ```
	CreateWallet(ctx context.Context, in *CreateWalletRequest, opts ...grpc.CallOption) (*CreateWalletResponse, error)
	// *
	// UnlockWallet sends an unlock rpc command to the engine to allow funds to be used
	// in the event that the broker has been taken offline -> online
	//
	// This RPC will be required after every application restart, if each engine's wallet has been
	// created. If you need to create a wallet for daemon, please refer to `CreateWallet`
	//
	// ```javascript
	// await walletService.unlockWallet({ symbol: 'BTC', password: 'your-secure-password')
	// ```
	//
	// ```shell
	// > sparkswap wallet unlock BTC
	// ```
	//
	// > The above command will print:
	//
	// ```javascript
	// {}
	// ```
	//
	// ```shell
	// Successfully Unlocked BTC Wallet!
	// ```
	UnlockWallet(ctx context.Context, in *UnlockWalletRequest, opts ...grpc.CallOption) (*GoogleProtobuf_Empty, error)
}

type walletServiceClient struct {
	cc *grpc.ClientConn
}

func NewWalletServiceClient(cc *grpc.ClientConn) WalletServiceClient {
	return &walletServiceClient{cc}
}

func (c *walletServiceClient) NewDepositAddress(ctx context.Context, in *NewDepositAddressRequest, opts ...grpc.CallOption) (*NewDepositAddressResponse, error) {
	out := new(NewDepositAddressResponse)
	err := grpc.Invoke(ctx, "/broker.rpc.WalletService/NewDepositAddress", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletServiceClient) GetBalances(ctx context.Context, in *GoogleProtobuf_Empty, opts ...grpc.CallOption) (*GetBalancesResponse, error) {
	out := new(GetBalancesResponse)
	err := grpc.Invoke(ctx, "/broker.rpc.WalletService/GetBalances", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletServiceClient) Commit(ctx context.Context, in *CommitRequest, opts ...grpc.CallOption) (*GoogleProtobuf_Empty, error) {
	out := new(GoogleProtobuf_Empty)
	err := grpc.Invoke(ctx, "/broker.rpc.WalletService/Commit", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletServiceClient) ReleaseChannels(ctx context.Context, in *ReleaseChannelsRequest, opts ...grpc.CallOption) (*ReleaseChannelsResponse, error) {
	out := new(ReleaseChannelsResponse)
	err := grpc.Invoke(ctx, "/broker.rpc.WalletService/ReleaseChannels", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletServiceClient) GetPaymentChannelNetworkAddress(ctx context.Context, in *GetPaymentChannelNetworkAddressRequest, opts ...grpc.CallOption) (*GetPaymentChannelNetworkAddressResponse, error) {
	out := new(GetPaymentChannelNetworkAddressResponse)
	err := grpc.Invoke(ctx, "/broker.rpc.WalletService/GetPaymentChannelNetworkAddress", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletServiceClient) GetTradingCapacities(ctx context.Context, in *GetTradingCapacitiesRequest, opts ...grpc.CallOption) (*GetTradingCapacitiesResponse, error) {
	out := new(GetTradingCapacitiesResponse)
	err := grpc.Invoke(ctx, "/broker.rpc.WalletService/GetTradingCapacities", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletServiceClient) WithdrawFunds(ctx context.Context, in *WithdrawFundsRequest, opts ...grpc.CallOption) (*WithdrawFundsResponse, error) {
	out := new(WithdrawFundsResponse)
	err := grpc.Invoke(ctx, "/broker.rpc.WalletService/WithdrawFunds", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletServiceClient) CreateWallet(ctx context.Context, in *CreateWalletRequest, opts ...grpc.CallOption) (*CreateWalletResponse, error) {
	out := new(CreateWalletResponse)
	err := grpc.Invoke(ctx, "/broker.rpc.WalletService/CreateWallet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletServiceClient) UnlockWallet(ctx context.Context, in *UnlockWalletRequest, opts ...grpc.CallOption) (*GoogleProtobuf_Empty, error) {
	out := new(GoogleProtobuf_Empty)
	err := grpc.Invoke(ctx, "/broker.rpc.WalletService/UnlockWallet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for WalletService service

type WalletServiceServer interface {
	// *
	// NewDepositAddress generates a new address for the user to deposit currency into to be used for trading.
	// The address is managed by a wallet in an underlying Payment Channel Network node, and so should be considered a hot wallet.
	//
	// ```javascript
	// const address = await walletService.newDepositAddress({ symbol: 'BTC' })
	// console.log(address)
	// ```
	//
	// ```shell
	// > sparkswap wallet new-deposit-address BTC
	// ```
	//
	// > The above command will print:
	//
	// ```javascript
	// > TODO
	// ```
	//
	// ```shell
	// sb1qsakedujs4exdq5dz2cpldcph6hlvf82l8mn8uk
	// ```
	NewDepositAddress(context.Context, *NewDepositAddressRequest) (*NewDepositAddressResponse, error)
	// *
	// GetBalances retrieves the balance in all currency in wallets managed by Payment Channel Network nodes for this Broker.
	//
	// Balances are divided into `uncommittedBalance`, i.e. everything not in a channel, `totalChannelBalance` (i.e. everything in channels opened by the Payment Channel Network nodes),
	// `totalPendingChannelBalance`, i.e. funds in channels that have finished the funding workflow and are waiting for confirmations for the funding txn, and
	// `uncommittedPendingBalance`, i.e funds in channels that are pending closure or unconfirmed unspent outputs under control of the wallet.
	//
	// NOTE: If an engine is unavailable, the balances for the particular engine will be empty `''`
	//
	// ```javascript
	// const deadline = new Date().setSeconds(new Date().getSeconds() + 5)
	// walletService.getBalances({}, { deadline }, (err, { balances }) => {
	//   if (err) return console.error(err)
	//   console.log(balances)
	// })
	// ```
	//
	// ```shell
	// > sparkswap wallet balance
	// ```
	//
	// > The above command will print:
	//
	// ```javascript
	// [
	//   {
	//     "symbol": "BTC",
	//     "uncommittedBalance": "10.0000000000000000",
	//     "totalChannelBalance": "0.1670000000000000",
	//     "totalPendingChannelBalance": "0.0001000000000000",
	//     "uncommittedPendingBalance": "0"
	//   },
	//   {
	//     "symbol": "LTC",
	//     "uncommittedBalance": "10.0000000000000000",
	//     "totalChannelBalance": "0.1670000000000000",
	//     "totalPendingChannelBalance": "0.0002000000000000",
	//     "uncommittedPendingBalance": "0"
	//   }
	// ]
	// ```
	//
	// ```shell
	// Wallet Balances
	// ┌──────────┬──────────────────────────────────┬──────────────────────────────────┐
	// │          │ Committed (Pending)              │ Uncommitted (Pending)            │
	// ├──────────┼──────────────────────────────────┼──────────────────────────────────┤
	// │ BTC      │ 0.1676816500000000 (0.00000000)  │ 9.8321513500000000 (0.00000000)  │
	// ├──────────┼──────────────────────────────────┼──────────────────────────────────┤
	// │ LTC      │ 0.0000000000000000 (0.00000000)  │ 10.0000000000000000 (0.00000000) │
	// └──────────┴──────────────────────────────────┴──────────────────────────────────┘
	// ```
	GetBalances(context.Context, *GoogleProtobuf_Empty) (*GetBalancesResponse, error)
	// *
	// Commit opens a channel with the Relayer with the given amount of currency on the Broker's side, and requests that the Relayer open a channel to the Broker with the inverse currency of equivalent amount on the Relayer's side.
	// This allows the Broker to trade in the market, since it has an outgoing channel and an incoming channel.
	//
	// The market parameter will determine the inverse currency, if you commit LTC to the BTC/LTC market, the Broker will request a BTC channel to be opened from the Relayer.
	//
	// Since the Network is in testing stages, rather than relying on the Network's exchange rate between BTC and LTC to determine how large of a channel to open, we use a set rate of 60 LTC to 1 BTC.
	// This also has the property of matching the conversion used in LND, so that when we run into things like the max channel size (in place while LND is in Beta), we can be consistent with LTC and BTC.
	//
	// > The below command has no output, but will throw an error if one is encountered.
	//
	// ```javascript
	// const deadline = new Date().setSeconds(new Date().getSeconds() + 5)
	// walletService.commit(
	//   {
	//     // We are committing LTC to a channel on the BTC/LTC market
	//     // the Broker will request a BTC channel be opened back to itself.
	//     symbol: 'LTC',
	//     // The amount to commit to the channel in common units (e.g. 0.016 BTC).
	//     // The Broker will request a BTC channel of size 0.0167 / 60 be opened back to itself.
	//     balance: '0.0167',
	//     market: 'BTC/LTC'
	//   },
	//   { deadline },
	//   (err) => {
	//     if (err) return console.error(err)
	//   }
	// )
	// ```
	//
	// ```shell
	// > sparkswap wallet commit LTC --market BTC/LTC
	// ```
	Commit(context.Context, *CommitRequest) (*GoogleProtobuf_Empty, error)
	// *
	// ReleaseChannels closes all the channels on the given market.
	// If you pass in `BTC/LTC` as the market to releaseChannels, closeChannels will be called on both the BTC and LTC engines. If channels were closed,
	// there will an empty response unless an error is encountered.
	//
	// > The below command has no output, but will throw an error if one is encountered.
	//
	// ```javascript
	// walletService.releaseChannels( { market: 'BTC/LTC' }, (err) => {
	//   if (err) return console.error(err)
	// })
	// ```
	//
	// ```shell
	// > sparkswap wallet release --market BTC/LTC
	// ```
	//
	// > Additionally, you can pass a `force` flag which will force close channels on a specific market
	//
	// ```javascript
	// walletService.releaseChannels( { market: 'BTC/LTC', force: true }, (err) => {
	//   if (err) return console.error(err)
	// })
	// ```
	//
	// ```shell
	// > sparkswap wallet release --market BTC/LTC --force
	// ```
	//
	ReleaseChannels(context.Context, *ReleaseChannelsRequest) (*ReleaseChannelsResponse, error)
	// *
	// GetPaymentChannelNetworkAddress retrieves the Payment Channel Network Address for the given currency.
	//
	// ```javascript
	// const { paymentChannelNetworkAddress } = await walletService.getPaymentChannelNetworkAddress({ symbol: 'BTC' })
	// console.log(paymentChannelNetworkAddress)
	// ```
	//
	// ```shell
	// > sparkswap wallet network-address BTC
	// ```
	//
	// > The above command will print:
	//
	// ```javascript
	// > "025f08036e00e38468f52d68bb83939995440b72730bfaae99ace5630630997623@your.daemon:10113"
	// ```
	//
	// ```shell
	// 025f08036e00e38468f52d68bb83939995440b72730bfaae99ace5630630997623@your.daemon:10113
	// ```
	GetPaymentChannelNetworkAddress(context.Context, *GetPaymentChannelNetworkAddressRequest) (*GetPaymentChannelNetworkAddressResponse, error)
	// *
	// GetTradingCapacities retrieves the remote and local capacities from the base and counter engines active, pending and inactive channels.
	//
	// Capacities are divided into three categories, active, pending and inactive. Each of these categories are further broken down into
	// the categories local and remote. For example, the activeSendCapacity is the local capacity in active channels for that engine, where pendingReceiveCapacity
	// is the remote capacity in pending channels for that engine. The response from GetTradingCapacities is a baseSymbolCapacities and counterSymbolCapacities
	// object where the respective capacities are grouped.
	//
	// ```javascript
	// walletService.getTradingCapacities({market: 'BTC/LTC}, (err, { baseSymbolCapacities, counterSymbolCapacities }) => {
	//   if (err) return console.error(err)
	//   console.log(baseSymbolCapacities)
	//   console.log(counterSymbolCapacities)
	// })
	// ```
	//
	// ```shell
	// > sparkswap wallet network-status --market BTC/LTC
	// ```
	//
	// > The above command will print:
	//
	// ```javascript
	// { "symbol": "BTC",
	//   "activeSendCapacity": "0.16768165",
	//   "activeReceiveCapacity": "0.0027057",
	//   "pendingSendCapacity": "0",
	//   "pendingReceiveCapacity": "0",
	//   "inactiveSendCapacity": "0",
	//   "inactiveReceiveCapacity": "0"
	// },
	// { "symbol": "LTC",
	//   "activeSendCapacity": "0.16741015",
	//   "activeReceiveCapacity": "10.065967",
	//   "pendingSendCapacity": "0",
	//   "pendingReceiveCapacity": "0",
	//   "inactiveSendCapacity": "0",
	//   "inactiveReceiveCapacity": "0"
	// }
	// ```
	//
	// ```shell
	// BTC/LTC
	// ┌──────────────┬────────────────────────┬────────────────────────┐
	// │              │ BTC Capacity           │ LTC Capacity           │
	// ├──────────────┼────────────────────────┼────────────────────────┤
	// │ Available    │                        │                        │
	// ├──────────────┼────────────────────────┼────────────────────────┤
	// │   Buy BTC    │ 0.0000380000000000     │ 0.0000000000000000     │
	// ├──────────────┼────────────────────────┼────────────────────────┤
	// │   Sell BTC   │ 0.1436436500000000     │ 10.0599490000000000    │
	// ├──────────────┼────────────────────────┼────────────────────────┤
	// │ Outstanding  │                        │                        │
	// ├──────────────┼────────────────────────┼────────────────────────┤
	// │   Buy BTC    │ 0.0027057000000000     │ 0.1674101500000000     │
	// ├──────────────┼────────────────────────┼────────────────────────┤
	// │   Sell BTC   │ 0.1676816500000000     │ 10.0659670000000000    │
	// ├──────────────┼────────────────────────┼────────────────────────┤
	// │ Pending      │                        │                        │
	// ├──────────────┼────────────────────────┼────────────────────────┤
	// │   Buy BTC    │ 0.0000000000000000     │ 0.0000000000000000     │
	// ├──────────────┼────────────────────────┼────────────────────────┤
	// │   Sell BTC   │ 0.0000000000000000     │ 0.0000000000000000     │
	// ├──────────────┼────────────────────────┼────────────────────────┤
	// │ Inactive     │                        │                        │
	// ├──────────────┼────────────────────────┼────────────────────────┤
	// │   Buy BTC    │ 0.0000000000000000     │ 0.0000000000000000     │
	// ├──────────────┼────────────────────────┼────────────────────────┤
	// │   Sell BTC   │ 0.0000000000000000     │ 0.0000000000000000     │
	// └──────────────┴────────────────────────┴────────────────────────┘
	// ```
	GetTradingCapacities(context.Context, *GetTradingCapacitiesRequest) (*GetTradingCapacitiesResponse, error)
	// *
	// WithdrawFunds moves funds (of the specified currency and amount) to the specified address
	//
	// ```javascript
	// const { txid } = await walletService.withdrawFunds({ symbol: 'BTC', amount: '2', address: 'asdfasdf' })
	// console.log(txid)
	// ```
	//
	// ```shell
	// > sparkswap wallet withdraw BTC 10 --wallet-address asdfadf
	// ```
	//
	// > The above command will print:
	//
	// ```javascript
	// '66a581f618ee68dde53142c55e924d56cd2b2c169be5b374bc810ac692fb17fd'
	// ```
	//
	// ```shell
	// Successfully withdrew 2 BTC from your wallet! { id: '66a581f618ee68dde53142c55e924d56cd2b2c169be5b374bc810ac692fb17fd' }
	// ```
	WithdrawFunds(context.Context, *WithdrawFundsRequest) (*WithdrawFundsResponse, error)
	// *
	// CreateWallet creates a wallet within an engine. This RPC is used as during a 'first-use'
	// setup.
	//
	// When a broker daemon is first getting setup, no crypto-wallets will exist on any of
	// the provided engines. It is the user's responsiblity to create a wallet for each currency
	// and to save the backup information (password and cipher seeds) that are used and returned
	// from this method.
	//
	// ```javascript
	// const { recoverySeed } = await walletService.withdrawFunds({ symbol: 'BTC', password: 'your-secure-password')
	// console.log(recoverySeed)
	// ```
	//
	// ```shell
	// > sparkswap wallet create BTC
	// ```
	//
	// > The above command will print:
	//
	// ```javascript
	// [ 'your',
	//   'cipher'
	//    ... ]
	// ```
	//
	// ```shell
	// > Please enter a password:
	// > Please confirm password:
	// IMPORTANT: Please make a copy of the recovery seed below as you WILL NOT
	// be able to recover this information again. We recommend that you write
	// down all the secret words, and re-confirm the order they are written down
	//
	// [ 'your',
	//   'cipher'
	//    ... ]
	// ```
	CreateWallet(context.Context, *CreateWalletRequest) (*CreateWalletResponse, error)
	// *
	// UnlockWallet sends an unlock rpc command to the engine to allow funds to be used
	// in the event that the broker has been taken offline -> online
	//
	// This RPC will be required after every application restart, if each engine's wallet has been
	// created. If you need to create a wallet for daemon, please refer to `CreateWallet`
	//
	// ```javascript
	// await walletService.unlockWallet({ symbol: 'BTC', password: 'your-secure-password')
	// ```
	//
	// ```shell
	// > sparkswap wallet unlock BTC
	// ```
	//
	// > The above command will print:
	//
	// ```javascript
	// {}
	// ```
	//
	// ```shell
	// Successfully Unlocked BTC Wallet!
	// ```
	UnlockWallet(context.Context, *UnlockWalletRequest) (*GoogleProtobuf_Empty, error)
}

func RegisterWalletServiceServer(s *grpc.Server, srv WalletServiceServer) {
	s.RegisterService(&_WalletService_serviceDesc, srv)
}

func _WalletService_NewDepositAddress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NewDepositAddressRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletServiceServer).NewDepositAddress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/broker.rpc.WalletService/NewDepositAddress",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletServiceServer).NewDepositAddress(ctx, req.(*NewDepositAddressRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WalletService_GetBalances_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GoogleProtobuf_Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletServiceServer).GetBalances(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/broker.rpc.WalletService/GetBalances",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletServiceServer).GetBalances(ctx, req.(*GoogleProtobuf_Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _WalletService_Commit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CommitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletServiceServer).Commit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/broker.rpc.WalletService/Commit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletServiceServer).Commit(ctx, req.(*CommitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WalletService_ReleaseChannels_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReleaseChannelsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletServiceServer).ReleaseChannels(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/broker.rpc.WalletService/ReleaseChannels",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletServiceServer).ReleaseChannels(ctx, req.(*ReleaseChannelsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WalletService_GetPaymentChannelNetworkAddress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPaymentChannelNetworkAddressRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletServiceServer).GetPaymentChannelNetworkAddress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/broker.rpc.WalletService/GetPaymentChannelNetworkAddress",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletServiceServer).GetPaymentChannelNetworkAddress(ctx, req.(*GetPaymentChannelNetworkAddressRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WalletService_GetTradingCapacities_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTradingCapacitiesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletServiceServer).GetTradingCapacities(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/broker.rpc.WalletService/GetTradingCapacities",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletServiceServer).GetTradingCapacities(ctx, req.(*GetTradingCapacitiesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WalletService_WithdrawFunds_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WithdrawFundsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletServiceServer).WithdrawFunds(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/broker.rpc.WalletService/WithdrawFunds",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletServiceServer).WithdrawFunds(ctx, req.(*WithdrawFundsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WalletService_CreateWallet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateWalletRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletServiceServer).CreateWallet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/broker.rpc.WalletService/CreateWallet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletServiceServer).CreateWallet(ctx, req.(*CreateWalletRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WalletService_UnlockWallet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnlockWalletRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletServiceServer).UnlockWallet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/broker.rpc.WalletService/UnlockWallet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletServiceServer).UnlockWallet(ctx, req.(*UnlockWalletRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _WalletService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "broker.rpc.WalletService",
	HandlerType: (*WalletServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "NewDepositAddress",
			Handler:    _WalletService_NewDepositAddress_Handler,
		},
		{
			MethodName: "GetBalances",
			Handler:    _WalletService_GetBalances_Handler,
		},
		{
			MethodName: "Commit",
			Handler:    _WalletService_Commit_Handler,
		},
		{
			MethodName: "ReleaseChannels",
			Handler:    _WalletService_ReleaseChannels_Handler,
		},
		{
			MethodName: "GetPaymentChannelNetworkAddress",
			Handler:    _WalletService_GetPaymentChannelNetworkAddress_Handler,
		},
		{
			MethodName: "GetTradingCapacities",
			Handler:    _WalletService_GetTradingCapacities_Handler,
		},
		{
			MethodName: "WithdrawFunds",
			Handler:    _WalletService_WithdrawFunds_Handler,
		},
		{
			MethodName: "CreateWallet",
			Handler:    _WalletService_CreateWallet_Handler,
		},
		{
			MethodName: "UnlockWallet",
			Handler:    _WalletService_UnlockWallet_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "broker.proto",
}

// Client API for InfoService service

type InfoServiceClient interface {
	// *
	// getSupportedMarkets returns detailed information about markets currently supported on sparkswap.
	//
	// ```javascript
	// const deadline = new Date().setSeconds(new Date().getSeconds() + 5)
	// infoService.getSupportedMarkets({}, { deadline }, (err, { supportedMarkets }) => {
	//   if (err) return console.error(err)
	//   console.log({ supportedMarkets })
	// })
	// ```
	//
	// ```shell
	// > sparkswap info supported-markets
	// ```
	//
	// > The above command will print:
	//
	// ```javascript
	// {
	//   "supportedMarkets": [
	//     {
	//       "id": "BTC/LTC",
	//       "symbol": "BTC/LTC",
	//       "base": "BTC",
	//       "counter": "LTC",
	//       "active": true,
	//     }
	//   ]
	// }
	// ```
	//
	// ```shell
	// { supportedMarkets:
	//   [ { id: 'BTC/LTC',
	//       symbol: 'BTC/LTC',
	//       base: 'BTC',
	//       counter: 'LTC',
	//       active: true } ] }
	// ```
	GetSupportedMarkets(ctx context.Context, in *GoogleProtobuf_Empty, opts ...grpc.CallOption) (*GetSupportedMarketsResponse, error)
	// *
	// getMarketStats returns statistics (price ticker information) for a particular market/symbol for a period of the last 24 hours
	//
	// ```javascript
	// const deadline = new Date().setSeconds(new Date().getSeconds() + 5)
	// const market = "BTC/LTC"
	// infoService.getMarketStats({ market }, { deadline }, (err, res) => {
	//   if (err) return console.error(err)
	//   console.log(res)
	// })
	// ```
	//
	// ```shell
	// > sparkswap info market-stats --market BTC/LTC
	// ```
	//
	// > The above command will print:
	//
	// ```javascript
	// {
	//   "symbol": "BTC/LTC",
	//   "timestamp": "1537386049351518282",
	//   "datetime": "2018-09-19T19:40:49.350111174Z",
	//   "high": "59.313",
	//   "low": "59.212",
	//   "bid": "0.0001",
	//   "bidVolume": "59.311",
	//   "ask": "0.0001",
	//   "askVolume": "59.32",
	//   "vwap": "59.324",
	//   "baseVolume": "20.1233",
	//   "counterVolume": "1207.398"
	// }
	// ```
	//
	// ```shell
	// { "symbol": "BTC/LTC",
	//   "timestamp": "1537386049351518282",
	//   "datetime": "2018-09-19T19:40:49.350111174Z",
	//   "high": "59.313",
	//   "low": "59.212",
	//   "bid": "0.0001",
	//   "bidVolume": "59.311",
	//   "ask": "0.0001",
	//   "askVolume": "59.32",
	//   "vwap": "59.324",
	//   "baseVolume": "20.1233",
	//   "counterVolume": "1207.398" }
	// ```
	GetMarketStats(ctx context.Context, in *GetMarketStatsRequest, opts ...grpc.CallOption) (*GetMarketStatsResponse, error)
	// *
	// getTrades returns detailed information about trades from a given time range.
	//
	// ```javascript
	// const deadline = new Date().setSeconds(new Date().getSeconds() + 5)
	// infoService.getTrades(
	//   {
	//     market: 'BTC/LTC', // trading BTC and LTC
	//     since: '2018-09-20T18:58:07.866Z', // only retrieve records since this date
	//     limit: 10, // retrieve first 10 records
	//   }, { deadline }, (err, { trades }) => {
	//   if (err) return console.error(err)
	//   console.log({ trades })
	// }))
	// ```
	//
	// ```shell
	// > sparkswap info trades 2018-09-20T18:58:07.866Z 50 --market BTC/LTC
	// ```
	//
	// > The above command will print:
	//
	// ```javascript
	// { trades:
	//  [ { id: 'yK2LMkgQPZRk1riK9pgwIyVjr7xMFOgn0iCF6FPm',
	//    timestamp: '1537526431834',
	//    datetime: '2018-09-21T10:40:31.034Z',
	//    order: 'tgjXZ6Mr_xcRzjMZ4xUkNnUpHL7OuJvBbFGG-CTg',
	//    market: 'BTC/LTC',
	//    type: 'limit',
	//    side: 'buy',
	//    price: '0.0010000000000000',
	//    amount: '400.000000000000',
	//    info: '{"id":"yK2LMkgQPZRk1riK9pgwIyVjr7xMFOgn0iCF6FPm","timestamp":"1537526431834","datetime":"2018-09-21T10:40:31.034Z","order":"tgjXZ6Mr_xcRzjMZ4xUkNnUpHL7OuJvBbFGG-CTg","symbol":"BTC/LTC","type":"limit","side":"buy","price":"0.0010000000000000","amount":"400.000000000000"}' },
	//   { id: 'd4OlWlhKEe3D9-UmrwfpM7T0_2bd7t8BI4tZCuKP',
	//    timestamp: '1537527538513',
	//    datetime: '2018-09-21T10:58:58.513Z',
	//    order: 'W36W9r-krFzjv4L6CwOM1hoPthAd7tlqzSBHUKDt',
	//    market: 'BTC/LTC',
	//    type: 'limit',
	//    side: 'sell',
	//    price: '0.1000000000000000',
	//    amount: '50.000000000000000',
	//    info: '{"id":"d4OlWlhKEe3D9-UmrwfpM7T0_2bd7t8BI4tZCuKP","timestamp":"1537527538513","datetime":"2018-09-21T10:58:58.513Z","order":"W36W9r-krFzjv4L6CwOM1hoPthAd7tlqzSBHUKDt","symbol":"BTC/LTC","type":"limit","side":"sell","price":"0.1000000000000000","amount":"50.000000000000000"}' } ] }
	// ```
	//
	// ```shell
	// { trades:
	//  [ { id: 'yK2LMkgQPZRk1riK9pgwIyVjr7xMFOgn0iCF6FPm',
	//    timestamp: '1537526431834',
	//    datetime: '2018-09-21T10:40:31.034Z',
	//    order: 'tgjXZ6Mr_xcRzjMZ4xUkNnUpHL7OuJvBbFGG-CTg',
	//    market: 'BTC/LTC',
	//    type: 'limit',
	//    side: 'buy',
	//    price: '0.0010000000000000',
	//    amount: '400.000000000000',
	//    info: '{"id":"yK2LMkgQPZRk1riK9pgwIyVjr7xMFOgn0iCF6FPm","timestamp":"1537526431834","datetime":"2018-09-21T10:40:31.034Z","order":"tgjXZ6Mr_xcRzjMZ4xUkNnUpHL7OuJvBbFGG-CTg","symbol":"BTC/LTC","type":"limit","side":"buy","price":"0.0010000000000000","amount":"400.000000000000"}' },
	//   { id: 'd4OlWlhKEe3D9-UmrwfpM7T0_2bd7t8BI4tZCuKP',
	//    timestamp: '1537527538513',
	//    datetime: '2018-09-21T10:58:58.513Z',
	//    order: 'W36W9r-krFzjv4L6CwOM1hoPthAd7tlqzSBHUKDt',
	//    market: 'BTC/LTC',
	//    type: 'limit',
	//    side: 'sell',
	//    price: '0.1000000000000000',
	//    amount: '50.000000000000000',
	//    info: '{"id":"d4OlWlhKEe3D9-UmrwfpM7T0_2bd7t8BI4tZCuKP","timestamp":"1537527538513","datetime":"2018-09-21T10:58:58.513Z","order":"W36W9r-krFzjv4L6CwOM1hoPthAd7tlqzSBHUKDt","symbol":"BTC/LTC","type":"limit","side":"sell","price":"0.1000000000000000","amount":"50.000000000000000"}' } ] }
	// ```
	GetTrades(ctx context.Context, in *GetTradesRequest, opts ...grpc.CallOption) (*GetTradesResponse, error)
}

type infoServiceClient struct {
	cc *grpc.ClientConn
}

func NewInfoServiceClient(cc *grpc.ClientConn) InfoServiceClient {
	return &infoServiceClient{cc}
}

func (c *infoServiceClient) GetSupportedMarkets(ctx context.Context, in *GoogleProtobuf_Empty, opts ...grpc.CallOption) (*GetSupportedMarketsResponse, error) {
	out := new(GetSupportedMarketsResponse)
	err := grpc.Invoke(ctx, "/broker.rpc.InfoService/getSupportedMarkets", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *infoServiceClient) GetMarketStats(ctx context.Context, in *GetMarketStatsRequest, opts ...grpc.CallOption) (*GetMarketStatsResponse, error) {
	out := new(GetMarketStatsResponse)
	err := grpc.Invoke(ctx, "/broker.rpc.InfoService/getMarketStats", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *infoServiceClient) GetTrades(ctx context.Context, in *GetTradesRequest, opts ...grpc.CallOption) (*GetTradesResponse, error) {
	out := new(GetTradesResponse)
	err := grpc.Invoke(ctx, "/broker.rpc.InfoService/GetTrades", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for InfoService service

type InfoServiceServer interface {
	// *
	// getSupportedMarkets returns detailed information about markets currently supported on sparkswap.
	//
	// ```javascript
	// const deadline = new Date().setSeconds(new Date().getSeconds() + 5)
	// infoService.getSupportedMarkets({}, { deadline }, (err, { supportedMarkets }) => {
	//   if (err) return console.error(err)
	//   console.log({ supportedMarkets })
	// })
	// ```
	//
	// ```shell
	// > sparkswap info supported-markets
	// ```
	//
	// > The above command will print:
	//
	// ```javascript
	// {
	//   "supportedMarkets": [
	//     {
	//       "id": "BTC/LTC",
	//       "symbol": "BTC/LTC",
	//       "base": "BTC",
	//       "counter": "LTC",
	//       "active": true,
	//     }
	//   ]
	// }
	// ```
	//
	// ```shell
	// { supportedMarkets:
	//   [ { id: 'BTC/LTC',
	//       symbol: 'BTC/LTC',
	//       base: 'BTC',
	//       counter: 'LTC',
	//       active: true } ] }
	// ```
	GetSupportedMarkets(context.Context, *GoogleProtobuf_Empty) (*GetSupportedMarketsResponse, error)
	// *
	// getMarketStats returns statistics (price ticker information) for a particular market/symbol for a period of the last 24 hours
	//
	// ```javascript
	// const deadline = new Date().setSeconds(new Date().getSeconds() + 5)
	// const market = "BTC/LTC"
	// infoService.getMarketStats({ market }, { deadline }, (err, res) => {
	//   if (err) return console.error(err)
	//   console.log(res)
	// })
	// ```
	//
	// ```shell
	// > sparkswap info market-stats --market BTC/LTC
	// ```
	//
	// > The above command will print:
	//
	// ```javascript
	// {
	//   "symbol": "BTC/LTC",
	//   "timestamp": "1537386049351518282",
	//   "datetime": "2018-09-19T19:40:49.350111174Z",
	//   "high": "59.313",
	//   "low": "59.212",
	//   "bid": "0.0001",
	//   "bidVolume": "59.311",
	//   "ask": "0.0001",
	//   "askVolume": "59.32",
	//   "vwap": "59.324",
	//   "baseVolume": "20.1233",
	//   "counterVolume": "1207.398"
	// }
	// ```
	//
	// ```shell
	// { "symbol": "BTC/LTC",
	//   "timestamp": "1537386049351518282",
	//   "datetime": "2018-09-19T19:40:49.350111174Z",
	//   "high": "59.313",
	//   "low": "59.212",
	//   "bid": "0.0001",
	//   "bidVolume": "59.311",
	//   "ask": "0.0001",
	//   "askVolume": "59.32",
	//   "vwap": "59.324",
	//   "baseVolume": "20.1233",
	//   "counterVolume": "1207.398" }
	// ```
	GetMarketStats(context.Context, *GetMarketStatsRequest) (*GetMarketStatsResponse, error)
	// *
	// getTrades returns detailed information about trades from a given time range.
	//
	// ```javascript
	// const deadline = new Date().setSeconds(new Date().getSeconds() + 5)
	// infoService.getTrades(
	//   {
	//     market: 'BTC/LTC', // trading BTC and LTC
	//     since: '2018-09-20T18:58:07.866Z', // only retrieve records since this date
	//     limit: 10, // retrieve first 10 records
	//   }, { deadline }, (err, { trades }) => {
	//   if (err) return console.error(err)
	//   console.log({ trades })
	// }))
	// ```
	//
	// ```shell
	// > sparkswap info trades 2018-09-20T18:58:07.866Z 50 --market BTC/LTC
	// ```
	//
	// > The above command will print:
	//
	// ```javascript
	// { trades:
	//  [ { id: 'yK2LMkgQPZRk1riK9pgwIyVjr7xMFOgn0iCF6FPm',
	//    timestamp: '1537526431834',
	//    datetime: '2018-09-21T10:40:31.034Z',
	//    order: 'tgjXZ6Mr_xcRzjMZ4xUkNnUpHL7OuJvBbFGG-CTg',
	//    market: 'BTC/LTC',
	//    type: 'limit',
	//    side: 'buy',
	//    price: '0.0010000000000000',
	//    amount: '400.000000000000',
	//    info: '{"id":"yK2LMkgQPZRk1riK9pgwIyVjr7xMFOgn0iCF6FPm","timestamp":"1537526431834","datetime":"2018-09-21T10:40:31.034Z","order":"tgjXZ6Mr_xcRzjMZ4xUkNnUpHL7OuJvBbFGG-CTg","symbol":"BTC/LTC","type":"limit","side":"buy","price":"0.0010000000000000","amount":"400.000000000000"}' },
	//   { id: 'd4OlWlhKEe3D9-UmrwfpM7T0_2bd7t8BI4tZCuKP',
	//    timestamp: '1537527538513',
	//    datetime: '2018-09-21T10:58:58.513Z',
	//    order: 'W36W9r-krFzjv4L6CwOM1hoPthAd7tlqzSBHUKDt',
	//    market: 'BTC/LTC',
	//    type: 'limit',
	//    side: 'sell',
	//    price: '0.1000000000000000',
	//    amount: '50.000000000000000',
	//    info: '{"id":"d4OlWlhKEe3D9-UmrwfpM7T0_2bd7t8BI4tZCuKP","timestamp":"1537527538513","datetime":"2018-09-21T10:58:58.513Z","order":"W36W9r-krFzjv4L6CwOM1hoPthAd7tlqzSBHUKDt","symbol":"BTC/LTC","type":"limit","side":"sell","price":"0.1000000000000000","amount":"50.000000000000000"}' } ] }
	// ```
	//
	// ```shell
	// { trades:
	//  [ { id: 'yK2LMkgQPZRk1riK9pgwIyVjr7xMFOgn0iCF6FPm',
	//    timestamp: '1537526431834',
	//    datetime: '2018-09-21T10:40:31.034Z',
	//    order: 'tgjXZ6Mr_xcRzjMZ4xUkNnUpHL7OuJvBbFGG-CTg',
	//    market: 'BTC/LTC',
	//    type: 'limit',
	//    side: 'buy',
	//    price: '0.0010000000000000',
	//    amount: '400.000000000000',
	//    info: '{"id":"yK2LMkgQPZRk1riK9pgwIyVjr7xMFOgn0iCF6FPm","timestamp":"1537526431834","datetime":"2018-09-21T10:40:31.034Z","order":"tgjXZ6Mr_xcRzjMZ4xUkNnUpHL7OuJvBbFGG-CTg","symbol":"BTC/LTC","type":"limit","side":"buy","price":"0.0010000000000000","amount":"400.000000000000"}' },
	//   { id: 'd4OlWlhKEe3D9-UmrwfpM7T0_2bd7t8BI4tZCuKP',
	//    timestamp: '1537527538513',
	//    datetime: '2018-09-21T10:58:58.513Z',
	//    order: 'W36W9r-krFzjv4L6CwOM1hoPthAd7tlqzSBHUKDt',
	//    market: 'BTC/LTC',
	//    type: 'limit',
	//    side: 'sell',
	//    price: '0.1000000000000000',
	//    amount: '50.000000000000000',
	//    info: '{"id":"d4OlWlhKEe3D9-UmrwfpM7T0_2bd7t8BI4tZCuKP","timestamp":"1537527538513","datetime":"2018-09-21T10:58:58.513Z","order":"W36W9r-krFzjv4L6CwOM1hoPthAd7tlqzSBHUKDt","symbol":"BTC/LTC","type":"limit","side":"sell","price":"0.1000000000000000","amount":"50.000000000000000"}' } ] }
	// ```
	GetTrades(context.Context, *GetTradesRequest) (*GetTradesResponse, error)
}

func RegisterInfoServiceServer(s *grpc.Server, srv InfoServiceServer) {
	s.RegisterService(&_InfoService_serviceDesc, srv)
}

func _InfoService_GetSupportedMarkets_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GoogleProtobuf_Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InfoServiceServer).GetSupportedMarkets(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/broker.rpc.InfoService/GetSupportedMarkets",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InfoServiceServer).GetSupportedMarkets(ctx, req.(*GoogleProtobuf_Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _InfoService_GetMarketStats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMarketStatsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InfoServiceServer).GetMarketStats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/broker.rpc.InfoService/GetMarketStats",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InfoServiceServer).GetMarketStats(ctx, req.(*GetMarketStatsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InfoService_GetTrades_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTradesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InfoServiceServer).GetTrades(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/broker.rpc.InfoService/GetTrades",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InfoServiceServer).GetTrades(ctx, req.(*GetTradesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _InfoService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "broker.rpc.InfoService",
	HandlerType: (*InfoServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "getSupportedMarkets",
			Handler:    _InfoService_GetSupportedMarkets_Handler,
		},
		{
			MethodName: "getMarketStats",
			Handler:    _InfoService_GetMarketStats_Handler,
		},
		{
			MethodName: "GetTrades",
			Handler:    _InfoService_GetTrades_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "broker.proto",
}

func init() { proto.RegisterFile("broker.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 2679 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x59, 0xcd, 0x6f, 0x1b, 0xc7,
	0x15, 0xf7, 0xf2, 0x43, 0x22, 0x1f, 0x49, 0x89, 0x1a, 0x52, 0x12, 0x45, 0x4b, 0xb1, 0xb2, 0x76,
	0x12, 0x45, 0x4d, 0xa5, 0x94, 0x4e, 0x82, 0xd6, 0x71, 0x1d, 0x53, 0x14, 0x65, 0x2b, 0x76, 0x6c,
	0x75, 0xa5, 0xd8, 0x39, 0xb4, 0x20, 0x96, 0xdc, 0xb1, 0xb4, 0x20, 0xb9, 0xcb, 0xec, 0x2e, 0xa5,
	0x12, 0x6d, 0x11, 0x20, 0xbd, 0xf5, 0xd0, 0x43, 0x7b, 0x28, 0xd0, 0x4b, 0x2f, 0xfd, 0x0b, 0x72,
	0xee, 0x5f, 0xd0, 0x43, 0x7b, 0x28, 0xda, 0xbf, 0xa0, 0xc7, 0x02, 0x45, 0xcf, 0xbd, 0x14, 0xf3,
	0xb1, 0xbb, 0x33, 0xcb, 0xe5, 0x87, 0x15, 0xa0, 0x17, 0x82, 0x33, 0xf3, 0xbe, 0xe6, 0xbd, 0xdf,
	0xbc, 0x79, 0x6f, 0x16, 0xf2, 0x6d, 0xc7, 0xee, 0x62, 0x67, 0x6f, 0xe0, 0xd8, 0x9e, 0x8d, 0x80,
	0x8f, 0x9c, 0x41, 0xa7, 0xba, 0x79, 0x6e, 0xdb, 0xe7, 0x3d, 0xbc, 0xaf, 0x0f, 0xcc, 0x7d, 0xdd,
	0xb2, 0x6c, 0x4f, 0xf7, 0x4c, 0xdb, 0x72, 0x19, 0xa5, 0xba, 0x05, 0x0b, 0x6c, 0xbd, 0x5a, 0x82,
	0x0c, 0x9d, 0x6a, 0x0f, 0x5f, 0x55, 0x17, 0x21, 0xdd, 0xec, 0x0f, 0xbc, 0x91, 0xfa, 0x57, 0x05,
	0x4a, 0x8f, 0xb1, 0xde, 0xf3, 0x2e, 0x1a, 0x17, 0xb8, 0xd3, 0xd5, 0xb0, 0x3b, 0xb0, 0x2d, 0x17,
	0xa3, 0x1f, 0x41, 0x01, 0x5b, 0xe7, 0xa6, 0x85, 0x5b, 0xae, 0xa7, 0x7b, 0x43, 0xb7, 0xa2, 0x6c,
	0x27, 0x77, 0x72, 0xb5, 0xf7, 0xf6, 0x42, 0xc5, 0x7b, 0x31, 0x7c, 0x7b, 0x4d, 0xca, 0x74, 0x4a,
	0x79, 0xb4, 0x3c, 0x16, 0x46, 0xe8, 0x2d, 0x58, 0x72, 0x70, 0x4f, 0x1f, 0x61, 0xc7, 0x97, 0x99,
	0xd8, 0x56, 0x76, 0xb2, 0x5a, 0x81, 0xcf, 0x32, 0xb2, 0xea, 0x03, 0xc8, 0x8b, 0x42, 0xd0, 0x1a,
	0x2c, 0xb8, 0xa3, 0x7e, 0xdb, 0xee, 0x55, 0x14, 0x4a, 0xce, 0x47, 0x74, 0x5e, 0x14, 0xc3, 0x47,
	0xea, 0x07, 0x50, 0x7a, 0x84, 0xbd, 0x63, 0x03, 0x5b, 0x9e, 0xe9, 0x8d, 0x82, 0x0d, 0x6d, 0x01,
	0x0c, 0x86, 0xed, 0x9e, 0xd9, 0x69, 0x75, 0xf1, 0x88, 0x8b, 0xca, 0xb2, 0x99, 0x27, 0x78, 0xa4,
	0xfe, 0x3a, 0x01, 0xeb, 0x0d, 0x07, 0xeb, 0x1e, 0x3e, 0xe8, 0xd9, 0x9d, 0xee, 0x73, 0xc7, 0xc0,
	0x8e, 0x86, 0xbf, 0x1c, 0x62, 0xd7, 0x23, 0x9a, 0xfa, 0xba, 0xd3, 0xc5, 0x9e, 0x6f, 0x01, 0x1b,
	0xa1, 0x3b, 0x90, 0x72, 0x4d, 0x03, 0x53, 0xfd, 0x4b, 0xb5, 0xa2, 0xe8, 0x9a, 0x53, 0xd3, 0xc0,
	0x1a, 0x5d, 0x25, 0xdc, 0x7a, 0xdf, 0x1e, 0x5a, 0x5e, 0x25, 0xc9, 0xb8, 0xd9, 0x08, 0xed, 0xc0,
	0xb2, 0xe9, 0xb6, 0x98, 0xa8, 0x96, 0x4d, 0xf4, 0x55, 0x52, 0xdb, 0xca, 0x4e, 0xe6, 0xf1, 0x0d,
	0xad, 0x60, 0xba, 0x9f, 0xd1, 0x79, 0x6a, 0x06, 0x7a, 0x13, 0x72, 0x3d, 0xb3, 0x6f, 0x7a, 0xad,
	0x81, 0x63, 0x76, 0x70, 0x25, 0x4d, 0xc4, 0x3c, 0xbe, 0xa1, 0x01, 0x9d, 0x3c, 0x21, 0x73, 0xe8,
	0x63, 0x28, 0x78, 0x66, 0x1f, 0xb7, 0x4c, 0xab, 0xf5, 0xca, 0x76, 0x3a, 0xb8, 0xb2, 0x40, 0x6d,
	0x5a, 0x17, 0x6d, 0x3a, 0x33, 0xfb, 0xf8, 0xd8, 0x3a, 0x22, 0xcb, 0x5a, 0xce, 0x0b, 0x07, 0x07,
	0x25, 0x58, 0xa1, 0x92, 0x5b, 0x0e, 0x76, 0x3d, 0xc7, 0xec, 0x10, 0xf8, 0xa8, 0x0f, 0xa1, 0x32,
	0xee, 0x0f, 0xee, 0xcb, 0x3b, 0xb0, 0xd4, 0x26, 0xb3, 0xcc, 0xec, 0x96, 0x69, 0x70, 0xc7, 0xe4,
	0xdb, 0x01, 0xed, 0xb1, 0xa1, 0xfe, 0x26, 0x01, 0x69, 0xb6, 0x81, 0x0d, 0xc8, 0x44, 0x28, 0x17,
	0x6d, 0x46, 0x84, 0x1e, 0x42, 0x9e, 0x2d, 0x09, 0xb1, 0x5c, 0xaa, 0x6d, 0x89, 0x76, 0x53, 0x19,
	0xec, 0x97, 0xe3, 0x2a, 0x67, 0x87, 0x83, 0x89, 0xfe, 0x2d, 0x43, 0x9a, 0xf9, 0x2b, 0x45, 0xa7,
	0xd9, 0x00, 0xdd, 0x02, 0xc6, 0xdc, 0xc2, 0x8e, 0x63, 0x3b, 0xd4, 0x4d, 0x59, 0x0d, 0xe8, 0x54,
	0x93, 0xcc, 0xa8, 0x3f, 0x81, 0x9c, 0xa0, 0x0a, 0xe5, 0x60, 0xb1, 0xa1, 0x35, 0xeb, 0x67, 0xcd,
	0xc3, 0xe2, 0x0d, 0x04, 0xb0, 0x70, 0xf2, 0xb4, 0xde, 0x68, 0x1e, 0x16, 0x15, 0xf2, 0xff, 0xe8,
	0xf8, 0xe9, 0xd3, 0xe6, 0x61, 0x31, 0x81, 0xf2, 0x90, 0x69, 0x7e, 0xd1, 0x6c, 0x7c, 0x4e, 0xa8,
	0x92, 0xa8, 0x00, 0xd9, 0xc6, 0xf3, 0xcf, 0x4e, 0x9e, 0x36, 0xc9, 0x30, 0x45, 0x16, 0xb5, 0xe6,
	0xa7, 0xcd, 0x06, 0x19, 0xa5, 0xd5, 0xdf, 0x25, 0x20, 0x75, 0x64, 0xf6, 0x7a, 0xd3, 0x7c, 0xb2,
	0x0e, 0x8b, 0xaf, 0xcc, 0x5e, 0x8f, 0xac, 0x70, 0x68, 0x93, 0xe1, 0xb1, 0x81, 0xee, 0x43, 0x8e,
	0x2e, 0x70, 0x5f, 0x25, 0xa9, 0xaf, 0x6e, 0x8a, 0xbe, 0x22, 0xa2, 0xe9, 0x0f, 0xf7, 0x14, 0xbc,
	0x0a, 0xfe, 0x0b, 0x8e, 0x4a, 0xc5, 0x3b, 0x2a, 0x2d, 0x3a, 0x6a, 0x0b, 0x28, 0xaf, 0xe4, 0xa7,
	0x2c, 0x99, 0x61, 0x6e, 0x3a, 0x01, 0x08, 0xd5, 0x8c, 0x79, 0x89, 0x7b, 0x46, 0x91, 0x3c, 0x93,
	0x90, 0x3d, 0x93, 0x94, 0x3c, 0x93, 0x52, 0xff, 0x95, 0x04, 0x08, 0xb1, 0x36, 0x1f, 0xc6, 0x84,
	0xa3, 0x99, 0x88, 0x3d, 0x9a, 0xc9, 0x39, 0x8f, 0x66, 0x6a, 0xd6, 0xd1, 0x2c, 0xcc, 0x75, 0x34,
	0x97, 0xe6, 0x39, 0x9a, 0xe9, 0xf9, 0x8f, 0x26, 0xfa, 0x24, 0x48, 0x72, 0xec, 0x40, 0xbf, 0x23,
	0x72, 0x85, 0xde, 0x12, 0xfe, 0xf2, 0xc0, 0x73, 0x36, 0xb4, 0x09, 0x59, 0x22, 0xcf, 0xf5, 0xf4,
	0xfe, 0xa0, 0xb2, 0xc8, 0xa2, 0x18, 0x4c, 0xa0, 0x2a, 0x64, 0x0c, 0xdd, 0xc3, 0x64, 0xa2, 0x92,
	0xa1, 0x8b, 0xc1, 0x58, 0x7d, 0x0c, 0xc5, 0xa8, 0x54, 0x12, 0xda, 0x7a, 0xe3, 0xec, 0xf8, 0x45,
	0xb3, 0x78, 0x83, 0x06, 0xb3, 0xfe, 0xac, 0xd1, 0xe4, 0x91, 0x96, 0x62, 0x9b, 0xa0, 0x20, 0xa8,
	0x1f, 0x93, 0xa5, 0x64, 0x7c, 0x7e, 0xb9, 0x0f, 0xe5, 0x47, 0xd8, 0x1b, 0x4f, 0xb6, 0xf3, 0xe5,
	0x96, 0xff, 0x26, 0x61, 0x35, 0xc2, 0xce, 0x73, 0x53, 0xe8, 0x31, 0xe5, 0x7a, 0x1e, 0x0b, 0x21,
	0x05, 0xb1, 0x90, 0xca, 0xcd, 0x09, 0xa9, 0xfc, 0xff, 0x11, 0x52, 0xcb, 0xaf, 0x01, 0x29, 0x09,
	0x11, 0xc5, 0x69, 0x88, 0x58, 0x91, 0x11, 0x41, 0x72, 0x27, 0x4d, 0x09, 0x7c, 0x83, 0x65, 0x96,
	0x3b, 0xc9, 0x54, 0x9d, 0x6d, 0xf2, 0x5d, 0x58, 0xa0, 0x5b, 0x73, 0x2b, 0xab, 0xb4, 0x5a, 0x58,
	0x19, 0x4b, 0xe3, 0x1a, 0x27, 0x40, 0x6f, 0x43, 0x9a, 0x30, 0xba, 0x95, 0x35, 0x4a, 0x59, 0x8c,
	0x26, 0x31, 0x8d, 0x2d, 0xc7, 0x63, 0xe7, 0x13, 0x58, 0x6f, 0xe8, 0x56, 0x07, 0xf7, 0xae, 0x0b,
	0x9f, 0x53, 0x58, 0x93, 0xd0, 0xe3, 0x06, 0xf0, 0xf9, 0x01, 0xe4, 0x05, 0x7e, 0xbf, 0xec, 0x59,
	0x8b, 0x07, 0x91, 0x96, 0x0b, 0xa5, 0xba, 0xea, 0x7e, 0x04, 0x92, 0xee, 0x8c, 0xfa, 0x41, 0x7d,
	0x0f, 0xd0, 0x4b, 0xdd, 0xeb, 0x5c, 0xb0, 0xe8, 0xcf, 0xa2, 0xfe, 0x46, 0x81, 0x92, 0x44, 0xce,
	0x2d, 0xfe, 0x21, 0xa4, 0xbc, 0xd1, 0x00, 0x73, 0xb8, 0xbf, 0x2b, 0x5a, 0x1a, 0x43, 0xbe, 0xd7,
	0xbc, 0xc4, 0x96, 0x77, 0x36, 0x1a, 0x60, 0x8d, 0xb2, 0xa1, 0x7b, 0x90, 0xe7, 0xa8, 0xc4, 0x64,
	0x85, 0xe6, 0xd1, 0x9c, 0x0c, 0x25, 0x26, 0x81, 0x32, 0x6a, 0xb9, 0x7e, 0x38, 0x50, 0xb7, 0x21,
	0x1b, 0x88, 0x43, 0x8b, 0x90, 0xac, 0x1f, 0xf2, 0xfc, 0x7f, 0xd8, 0x24, 0x79, 0xa0, 0xa8, 0xa8,
	0x3f, 0x87, 0x9c, 0xc0, 0x3d, 0xed, 0xd2, 0x0b, 0x0f, 0x4e, 0x22, 0xfe, 0x76, 0x4a, 0x8a, 0xb7,
	0x93, 0x7f, 0x18, 0x53, 0xd3, 0x0e, 0xa3, 0xfa, 0x5d, 0x5a, 0x0a, 0xd2, 0x60, 0xb4, 0x6d, 0xbb,
	0x3b, 0xcb, 0xc3, 0x77, 0x21, 0x79, 0x60, 0x1a, 0xa1, 0x46, 0x45, 0xd4, 0x38, 0xc1, 0x3e, 0xc2,
	0x54, 0x77, 0xbb, 0xaf, 0xc9, 0xf4, 0x7b, 0x85, 0x66, 0x3f, 0xc1, 0x32, 0x1e, 0xcc, 0xdb, 0x90,
	0x6a, 0x9b, 0x86, 0x0f, 0xbb, 0x65, 0x09, 0x76, 0xa6, 0xa1, 0xd1, 0x45, 0x42, 0xa4, 0xbb, 0x5d,
	0x52, 0x2b, 0x8d, 0x11, 0xd5, 0xdd, 0xae, 0x46, 0x17, 0xe5, 0x63, 0x4e, 0x7c, 0x97, 0x9c, 0x74,
	0xcc, 0x53, 0x91, 0xc4, 0x7f, 0x04, 0x95, 0x67, 0xf8, 0xea, 0x10, 0x0f, 0x6c, 0xd7, 0xf4, 0xea,
	0x86, 0xe1, 0x60, 0x37, 0x80, 0xf2, 0xae, 0x54, 0x8c, 0x2f, 0xd5, 0x90, 0xe4, 0x79, 0xba, 0xe2,
	0x17, 0xe8, 0xea, 0x87, 0xb0, 0x11, 0x23, 0x87, 0x6f, 0xb4, 0x02, 0x8b, 0x3a, 0x9b, 0xf2, 0x81,
	0xc0, 0x87, 0xea, 0x1f, 0x12, 0xb0, 0x78, 0xa0, 0xf7, 0xc8, 0xf9, 0x9e, 0x58, 0xfb, 0xef, 0x43,
	0x69, 0x68, 0x75, 0xec, 0x7e, 0xdf, 0xf4, 0x3c, 0x6c, 0xb4, 0xda, 0x8c, 0x9c, 0x3b, 0x19, 0x09,
	0x4b, 0xbe, 0xa0, 0x1a, 0xac, 0x7a, 0xb6, 0xa7, 0xf7, 0x5a, 0x9d, 0x0b, 0xdd, 0xb2, 0x70, 0x2f,
	0x60, 0x61, 0xa8, 0x2a, 0xd1, 0xc5, 0x06, 0x5b, 0xf3, 0x79, 0xea, 0xb0, 0xc5, 0x78, 0x06, 0xd8,
	0x32, 0x4c, 0xeb, 0x7c, 0x8c, 0x97, 0x39, 0xae, 0x4a, 0x89, 0x4e, 0x18, 0x4d, 0x44, 0xc4, 0x03,
	0xb8, 0x29, 0xda, 0xe9, 0x0b, 0xf2, 0x05, 0xb0, 0x82, 0x6b, 0x43, 0x20, 0xe1, 0x62, 0x7c, 0xfe,
	0x32, 0xa4, 0x59, 0xfd, 0xc5, 0xae, 0x22, 0x36, 0x50, 0x8f, 0x28, 0xac, 0x39, 0x4d, 0xe8, 0xd2,
	0x7d, 0xc8, 0x70, 0xc1, 0x3e, 0x7e, 0x4a, 0x12, 0x7e, 0xd8, 0x9a, 0x16, 0x10, 0xa9, 0x7f, 0x4c,
	0x41, 0xa6, 0xa1, 0x0f, 0xf4, 0x8e, 0xe9, 0x8d, 0x26, 0xba, 0xba, 0x06, 0xab, 0xbe, 0xd9, 0x2e,
	0xb6, 0x8c, 0x56, 0x87, 0x33, 0xf0, 0xdd, 0x97, 0xf8, 0xe2, 0x29, 0xb6, 0x8c, 0x40, 0xd6, 0xf7,
	0xa1, 0xe2, 0xf3, 0x38, 0xb8, 0x83, 0xcd, 0x4b, 0x1c, 0xb2, 0xb1, 0x3d, 0xaf, 0xf1, 0x75, 0x8d,
	0x2d, 0x07, 0x9c, 0x1f, 0xc0, 0x9a, 0x69, 0xe9, 0x1d, 0x8f, 0xb0, 0xc8, 0xea, 0x58, 0x05, 0x5a,
	0xf6, 0x57, 0x25, 0x7d, 0xf7, 0x60, 0x23, 0xe0, 0x1a, 0x53, 0xc8, 0x8a, 0x9e, 0x75, 0x9f, 0x20,
	0xaa, 0xf1, 0x23, 0x58, 0xd7, 0x2f, 0x75, 0xb3, 0xa7, 0xb7, 0x7b, 0x51, 0x95, 0xac, 0x22, 0x5a,
	0x0d, 0x96, 0x25, 0x9d, 0xf7, 0xa1, 0x1a, 0xf2, 0x8d, 0x29, 0xcd, 0x52, 0xd6, 0x4a, 0x40, 0x11,
	0xd5, 0x7a, 0x0f, 0x36, 0xec, 0xa1, 0xe7, 0x7a, 0x7a, 0x9c, 0x67, 0x59, 0xb0, 0xd7, 0x05, 0x02,
	0x49, 0xf3, 0x43, 0xd8, 0x14, 0x79, 0xc7, 0x74, 0xe7, 0x18, 0x2c, 0x05, 0x9a, 0xa8, 0xf6, 0xb0,
	0x75, 0x2e, 0x8b, 0xad, 0x73, 0x08, 0xb7, 0x55, 0x11, 0x6e, 0x7f, 0x52, 0x60, 0xf3, 0x11, 0xf6,
	0xce, 0x1c, 0x9d, 0x22, 0x9c, 0x09, 0x31, 0x05, 0xe0, 0x7d, 0x0a, 0x6b, 0x6d, 0xdd, 0xc5, 0x2d,
	0x86, 0x18, 0xdf, 0x10, 0x13, 0xb3, 0xa3, 0x9d, 0xab, 0x95, 0x45, 0x18, 0xfa, 0x46, 0x68, 0x65,
	0xc2, 0xc3, 0x52, 0x46, 0x28, 0x13, 0x9d, 0xc0, 0x46, 0x87, 0xa4, 0x48, 0xd2, 0x11, 0x8e, 0x89,
	0x4b, 0x4c, 0x11, 0xb7, 0xce, 0xd9, 0xa2, 0x12, 0xd5, 0x0f, 0xe1, 0x66, 0xbc, 0xf5, 0xd3, 0x2f,
	0x83, 0x3e, 0x14, 0x1a, 0xf4, 0x54, 0x5e, 0x23, 0xf5, 0x91, 0xec, 0x26, 0xe7, 0x24, 0x7f, 0x28,
	0xa8, 0x4b, 0x4a, 0xea, 0x8e, 0x60, 0x4d, 0xc3, 0x3d, 0xac, 0xbb, 0x98, 0xa7, 0x90, 0x59, 0x06,
	0x92, 0x60, 0xb1, 0xe2, 0x8f, 0x68, 0xc8, 0x68, 0x6c, 0xa0, 0x7e, 0x01, 0x45, 0x2e, 0xc7, 0x68,
	0x0c, 0x1d, 0x07, 0x5b, 0x9d, 0xd1, 0xeb, 0xbe, 0xa0, 0x4c, 0xc8, 0x3a, 0xbf, 0x54, 0x60, 0x7d,
	0xcc, 0x44, 0x8e, 0x80, 0xf7, 0x21, 0x45, 0xa2, 0xc9, 0xe3, 0xbd, 0x29, 0x7a, 0x26, 0x6a, 0x8d,
	0x46, 0x29, 0xd1, 0x47, 0xb0, 0xc8, 0x03, 0xc6, 0xa3, 0x3a, 0x9d, 0xc9, 0x27, 0x56, 0xcf, 0xe0,
	0xed, 0x47, 0xd8, 0x3b, 0xd1, 0x47, 0x7d, 0x6c, 0x79, 0xdc, 0x8e, 0x67, 0xd8, 0xbb, 0xb2, 0x9d,
	0xee, 0xb7, 0xb8, 0xaa, 0x06, 0xf0, 0xce, 0x4c, 0xa9, 0x7c, 0xab, 0x4d, 0xb8, 0x35, 0x60, 0x74,
	0xc1, 0x7d, 0x60, 0x31, 0xca, 0x96, 0x7c, 0xa1, 0x6d, 0x0e, 0xa6, 0x88, 0x53, 0x3d, 0x28, 0xbf,
	0x34, 0xbd, 0x0b, 0xc3, 0xd1, 0xaf, 0x8e, 0x86, 0x96, 0x71, 0x1d, 0xab, 0x27, 0x96, 0x4c, 0xc2,
	0xdd, 0x9a, 0x94, 0xef, 0xd6, 0xef, 0xc0, 0x6a, 0x44, 0x2b, 0xdf, 0x15, 0x82, 0x94, 0xf7, 0xd3,
	0xa0, 0x28, 0xa3, 0xff, 0xd5, 0x63, 0x28, 0xb1, 0x17, 0xa0, 0x97, 0x7a, 0xaf, 0x27, 0xd5, 0xa7,
	0xb1, 0x68, 0xaa, 0x42, 0x66, 0xa0, 0xbb, 0xee, 0x95, 0xed, 0xf8, 0xcf, 0x16, 0xc1, 0x58, 0xfd,
	0x18, 0xca, 0xb2, 0xa8, 0xa0, 0xdc, 0x29, 0x38, 0xb8, 0x63, 0x5f, 0x62, 0x67, 0xd4, 0x72, 0x31,
	0x36, 0xe8, 0xbd, 0x95, 0xd5, 0xf2, 0xfe, 0xe4, 0x29, 0xc6, 0xd4, 0x8e, 0xcf, 0x2d, 0x52, 0x55,
	0x7f, 0x7b, 0x3b, 0xbe, 0x82, 0xe5, 0xd3, 0xe1, 0x60, 0x60, 0x3b, 0x1e, 0x36, 0x58, 0x5d, 0x8a,
	0x96, 0x20, 0x11, 0xec, 0x3b, 0x61, 0x1a, 0x82, 0xd8, 0x84, 0x24, 0x16, 0x71, 0x88, 0x33, 0x8f,
	0x32, 0x10, 0x57, 0x42, 0x10, 0xb3, 0xdb, 0xd0, 0x1f, 0xd2, 0xd0, 0xd0, 0xeb, 0x86, 0xde, 0x77,
	0x19, 0x8d, 0x8f, 0xd4, 0x73, 0x9a, 0x8c, 0x22, 0x36, 0x84, 0x61, 0x78, 0x0c, 0x2b, 0xae, 0xbf,
	0xc6, 0x9b, 0x45, 0xff, 0x2e, 0x97, 0x9e, 0x79, 0x22, 0x02, 0xb4, 0xa2, 0x1b, 0x91, 0xc8, 0x9b,
	0x11, 0x36, 0x22, 0x0d, 0xee, 0xcc, 0x7c, 0xf7, 0xe7, 0x04, 0xed, 0x89, 0x24, 0x0e, 0x6e, 0xd5,
	0x24, 0x4f, 0x4b, 0x25, 0x66, 0x62, 0x5a, 0x89, 0x99, 0x8c, 0x74, 0x92, 0x08, 0x52, 0x17, 0xe6,
	0xf9, 0x05, 0xf7, 0x1a, 0xfd, 0x8f, 0x8a, 0x90, 0xec, 0xd9, 0x57, 0xbc, 0x3e, 0x20, 0x7f, 0xc9,
	0x4c, 0xdb, 0x34, 0xf8, 0xcd, 0x4f, 0xfe, 0x12, 0x8d, 0x6d, 0xd3, 0x78, 0x61, 0xf7, 0x86, 0x7d,
	0xec, 0xbf, 0x66, 0x04, 0x13, 0x84, 0x5e, 0x77, 0xbb, 0xfc, 0xda, 0x26, 0x7f, 0x09, 0xbd, 0xee,
	0x76, 0x39, 0x3d, 0xbb, 0x93, 0xc3, 0x09, 0x62, 0xc5, 0xe5, 0x95, 0x3e, 0xe0, 0x69, 0x8e, 0xfe,
	0x47, 0x6f, 0x00, 0x90, 0xd0, 0x72, 0x16, 0x76, 0x95, 0x0a, 0x33, 0xe8, 0x0e, 0x14, 0x78, 0x8c,
	0x39, 0x09, 0x6b, 0xf3, 0xe5, 0x49, 0xf5, 0x05, 0x14, 0xf9, 0x9d, 0x83, 0xe7, 0xc9, 0xe3, 0xae,
	0x19, 0xde, 0x14, 0x6c, 0x40, 0x66, 0x69, 0xc3, 0xcf, 0x4b, 0x77, 0x36, 0x50, 0xff, 0xae, 0x40,
	0x9a, 0x4a, 0x1d, 0x83, 0xed, 0x58, 0x2c, 0xb2, 0xf3, 0xc6, 0xa2, 0x0c, 0xe9, 0xf0, 0xf5, 0x39,
	0xab, 0xb1, 0x81, 0x60, 0x6d, 0x5a, 0xb2, 0x16, 0xf1, 0x6e, 0x73, 0x81, 0x27, 0x0a, 0xd2, 0xf9,
	0x21, 0xde, 0x8c, 0xb1, 0x80, 0xb0, 0x77, 0x90, 0xa0, 0x1f, 0xca, 0xc4, 0xf7, 0x43, 0x59, 0xa9,
	0x1f, 0x7a, 0x00, 0x2b, 0x82, 0xbf, 0x38, 0xec, 0xde, 0x85, 0x05, 0x8f, 0xce, 0xf0, 0x13, 0x20,
	0xbd, 0x26, 0x50, 0x5a, 0x8d, 0x13, 0xec, 0x56, 0x20, 0x45, 0xda, 0x3e, 0xd2, 0x83, 0x1e, 0x1c,
	0x93, 0x1e, 0x94, 0x34, 0xa3, 0xa7, 0x4f, 0x8a, 0xca, 0xee, 0x0e, 0xe4, 0x84, 0x97, 0x10, 0x32,
	0xff, 0xe8, 0xac, 0xc1, 0x08, 0x8e, 0x9e, 0x3f, 0x29, 0x2a, 0xe4, 0xcf, 0xf1, 0xf3, 0x46, 0x31,
	0xb1, 0x5b, 0x85, 0x05, 0x96, 0x5f, 0xa9, 0x14, 0x9f, 0xe8, 0xe9, 0x59, 0xa3, 0xa8, 0xd4, 0xfe,
	0xad, 0x40, 0xbe, 0x6e, 0xf4, 0x4d, 0xeb, 0x14, 0x3b, 0x97, 0x64, 0x23, 0x03, 0xc8, 0x09, 0x5f,
	0x3f, 0xd0, 0x9b, 0xa2, 0x69, 0xec, 0x73, 0xcb, 0x9e, 0xff, 0xad, 0x65, 0x8f, 0x7e, 0x68, 0xa9,
	0xde, 0x9a, 0xf1, 0xe5, 0x44, 0xdd, 0xfa, 0xfa, 0x6f, 0xff, 0xfc, 0x6d, 0x62, 0x1d, 0xad, 0xee,
	0x5f, 0x7e, 0x6f, 0x5f, 0x27, 0xca, 0xf6, 0x2f, 0x28, 0x59, 0x87, 0xaa, 0xe8, 0x43, 0x4e, 0xf8,
	0xac, 0xf1, 0xda, 0x1a, 0x63, 0x3e, 0x89, 0xa8, 0x55, 0xaa, 0xb1, 0x8c, 0x50, 0xa8, 0xd1, 0xe4,
	0x34, 0xb5, 0xff, 0x24, 0x21, 0xcf, 0x5e, 0xc7, 0xf8, 0x8e, 0x3d, 0x28, 0x46, 0xbf, 0x07, 0xa0,
	0xdb, 0x52, 0x25, 0x16, 0xff, 0xf5, 0xa4, 0x7a, 0x67, 0x3a, 0x11, 0xb7, 0x65, 0x95, 0xda, 0xb2,
	0xac, 0x02, 0xb1, 0x85, 0xbd, 0xbd, 0xdc, 0x53, 0x76, 0xd1, 0x08, 0x0a, 0xd2, 0x9b, 0x0a, 0xda,
	0x8e, 0x6c, 0x6a, 0x5c, 0xdf, 0x9b, 0x53, 0x28, 0xb8, 0xb2, 0xdb, 0x54, 0xd9, 0x16, 0xba, 0x19,
	0x2a, 0xdb, 0xff, 0x99, 0xfc, 0x6c, 0xf4, 0x0b, 0xf4, 0xb5, 0x02, 0xc5, 0xe8, 0x2b, 0x53, 0x64,
	0xc7, 0xf1, 0x6f, 0x50, 0xd5, 0xd9, 0xb1, 0x51, 0xdf, 0xa6, 0x16, 0x6c, 0xef, 0x4e, 0xb3, 0x80,
	0xec, 0xbf, 0x0b, 0x4b, 0xf2, 0x9b, 0x12, 0x9a, 0xbc, 0x3d, 0x3f, 0xd3, 0x54, 0xd5, 0x69, 0x24,
	0xdc, 0x05, 0x88, 0x1a, 0x90, 0x47, 0x82, 0xbf, 0x6b, 0x7f, 0x51, 0xa0, 0x48, 0xc9, 0x0e, 0x6c,
	0xbb, 0xeb, 0xc7, 0xfd, 0x04, 0x72, 0xc2, 0x33, 0x12, 0x7a, 0x63, 0xe2, 0xfb, 0x12, 0xd3, 0x7d,
	0x6b, 0xc6, 0xfb, 0xd3, 0xfb, 0x0a, 0xba, 0x80, 0xbc, 0xf8, 0xf6, 0x81, 0xa2, 0x38, 0x8d, 0xbe,
	0xd7, 0x54, 0xb7, 0x27, 0x13, 0xc8, 0xe8, 0x41, 0x85, 0x60, 0x37, 0x64, 0xb9, 0xf6, 0x4d, 0x06,
	0x0a, 0xac, 0x68, 0xf0, 0x77, 0xf3, 0x15, 0xac, 0x8c, 0xbd, 0x49, 0x20, 0x09, 0xa1, 0x93, 0x9e,
	0x3e, 0xaa, 0x6f, 0xcd, 0xa0, 0x92, 0x8f, 0xb1, 0x4a, 0x0f, 0xd5, 0x15, 0x55, 0xbe, 0xcf, 0xcb,
	0x2f, 0x12, 0x50, 0x8b, 0x1e, 0x63, 0xbf, 0x77, 0xbf, 0xce, 0x31, 0x8e, 0xf6, 0xfd, 0xea, 0x4d,
	0xaa, 0x71, 0x15, 0x95, 0x04, 0x8d, 0x7e, 0x8f, 0x8f, 0x0c, 0x58, 0x60, 0x6d, 0x0c, 0xda, 0x90,
	0xa0, 0x2b, 0xb6, 0x36, 0xf3, 0x00, 0x76, 0x93, 0x2a, 0x59, 0x53, 0x57, 0x04, 0x25, 0xec, 0xd5,
	0x82, 0x1d, 0xd3, 0xe5, 0x48, 0x6b, 0x80, 0xd4, 0x98, 0x7a, 0x3e, 0xd2, 0xda, 0x54, 0x6f, 0x4f,
	0xa5, 0x99, 0xe2, 0x50, 0x87, 0xd1, 0x12, 0xd5, 0xbf, 0x52, 0xe0, 0xd6, 0x8c, 0xda, 0x1d, 0xd5,
	0x22, 0x2e, 0x9c, 0xa3, 0x7d, 0xa8, 0xde, 0x7d, 0x2d, 0x1e, 0x7e, 0x65, 0x99, 0xf4, 0x59, 0x6f,
	0xac, 0xd7, 0x44, 0xef, 0x44, 0x84, 0x4d, 0xea, 0x46, 0xab, 0x3b, 0xb3, 0x09, 0xb9, 0x2a, 0x0f,
	0x0a, 0x52, 0x29, 0x2f, 0x67, 0xc6, 0xb8, 0xde, 0x42, 0x0e, 0x73, 0x6c, 0x1f, 0xa0, 0xbe, 0x41,
	0x9d, 0x5d, 0x51, 0x45, 0x2c, 0x5d, 0x71, 0x4a, 0xe2, 0x6d, 0x1b, 0xf2, 0x62, 0x21, 0x2f, 0x9f,
	0xdd, 0x98, 0x6e, 0x41, 0x3e, 0xbb, 0x71, 0x3d, 0x40, 0x3c, 0xb2, 0x28, 0x21, 0x51, 0x38, 0x80,
	0xbc, 0x58, 0xfc, 0xcb, 0x0a, 0x63, 0xda, 0x82, 0xeb, 0x62, 0x79, 0x48, 0x45, 0xdd, 0x53, 0x76,
	0x6b, 0xff, 0x48, 0x40, 0xee, 0xd8, 0x7a, 0x65, 0xfb, 0x29, 0xe3, 0x12, 0x4a, 0xe7, 0xe3, 0x25,
	0xfb, 0x3c, 0x27, 0x37, 0x1a, 0xf5, 0x49, 0x65, 0xbf, 0x5a, 0xa2, 0x06, 0x15, 0x50, 0x8e, 0x18,
	0xc4, 0xcb, 0x7e, 0xf4, 0x25, 0x2c, 0x9d, 0x4b, 0xf5, 0xf8, 0x58, 0xea, 0x1f, 0xaf, 0xee, 0xc7,
	0x52, 0x7f, 0x4c, 0x39, 0xaf, 0x56, 0xa8, 0x36, 0x84, 0x8a, 0xa1, 0x36, 0xfa, 0x45, 0xd9, 0x45,
	0x3f, 0x86, 0x6c, 0x50, 0x86, 0xa1, 0xcd, 0x18, 0x28, 0x86, 0x40, 0xdd, 0x9a, 0xb0, 0x1a, 0x77,
	0xbd, 0xb0, 0x22, 0xad, 0xbd, 0x40, 0xdd, 0x73, 0xf7, 0x7f, 0x01, 0x00, 0x00, 0xff, 0xff, 0x34,
	0x6f, 0x6c, 0xa4, 0xca, 0x22, 0x00, 0x00,
}
